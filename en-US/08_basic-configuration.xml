<?xml version="1.0"?>
<chapter id="basic-configuration">
  <chapterinfo>
    <mediaobject condition="pdf">
      <imageobject>
        <imagedata fileref="images/chap-basic-configuration.png" scalefit="1"/>
      </imageobject>
    </mediaobject>
    <keywordset>
      <keyword>Configuration</keyword>
      <keyword>Localization</keyword>
      <keyword>Locales</keyword>
      <keyword>Network</keyword>
      <keyword>Name resolution</keyword>
      <keyword>Users</keyword>
      <keyword>Groups</keyword>
      <keyword>Accounts</keyword>
      <keyword>Command-line interpreter</keyword>
      <keyword>Shell</keyword>
      <keyword>Printing</keyword>
      <keyword>Bootloader</keyword>
      <keyword>Kernel compiling</keyword>
    </keywordset>
  </chapterinfo>
  <title>Basic Configuration: Network, Accounts, Printing...</title>
  <highlights>
    <para>A computer with a new installation created with
    <command>debian-installer</command> is intended to be as functional as
    possible, but many services still have to be configured. Furthermore,
    it is always good to know how to change certain configuration elements
    defined during the initial installation process.</para>
  </highlights>

  <para>This chapter reviews everything included in what we could call the
  “basic configuration”: networking, language and locales, users and
  groups, printing, mount points, etc.</para>

  <section id="sect.config-language-support">
    <title>Configuring the System for Another Language</title>
    <indexterm><primary>French localization</primary></indexterm>

    <para>If the system was installed using French, the machine will
    probably already have French set as the default language. But it is
    good to know what the installer does to set the language, so that
    later, if the need arises, you can change it.</para>

    <sidebar>
      <title><emphasis>TOOL</emphasis> The <command>locale</command> command to display the current configuration</title>

      <para>The <command>locale</command> command lists a summary of the
      current configuration of various locale parameters (date format,
      numbers format, etc.), presented in the form of a group of standard
      environment variables dedicated to the dynamic modification of these
      settings.</para>
    </sidebar>

    <section id="sect.default-language">
      <title>Setting the Default Language</title>
      <indexterm><primary>locales</primary></indexterm>
      <indexterm><primary>language</primary></indexterm>
      <indexterm><primary><command>locale-gen</command></primary></indexterm>

      <para>A locale is a group of regional settings. This includes not
      only the language for text, but also the format for displaying
      numbers, dates, times, and monetary sums, as well as the alphabetical
      comparison rules (to properly account for accented characters).
      Although each of
      these parameters can be specified independently from the others, we
      generally use a locale, which is a coherent set of values for
      these parameters corresponding to a “region” in the broadest
      sense. These locales are usually indicated under the form,
      <literal><replaceable>language-code</replaceable>_<replaceable>COUNTRY-CODE</replaceable></literal>,
      sometimes with a suffix to specify the character set and encoding to
      be used. This enables consideration of idiomatic or typographical
      differences between different regions with a common language.</para>

      <sidebar>
        <title><emphasis>CULTURE</emphasis> Character sets</title>
        <indexterm><primary>character set</primary></indexterm>
        <indexterm><primary>encoding</primary></indexterm>
        <indexterm><primary>ISO-8859-1</primary></indexterm>
        <indexterm><primary>ISO-8859-15</primary></indexterm>
        <indexterm><primary>Latin 1</primary></indexterm>
        <indexterm><primary>Latin 9</primary></indexterm>

	<para>Historically, each locale has an associated “character
	set” (group of known characters) and a preferred “encoding”
	(internal representation for characters within the computer).</para>

	<para>The most popular encodings for latin-based languages were
	limited to 256 characters because they opted to use a single byte
	for each character. Since 256 characters was not enough to cover
	all European languages, multiple encodings were needed, and
	that's how we ended up with <emphasis>ISO-8859-1</emphasis>
	(also known as “Latin 1”) up to <emphasis>ISO-8859-15</emphasis>
	(also known as “Latin 9”), among others.</para>

	<para>Working with foreign languages often implied regular switches
	between various encodings and character sets. Furthermore, writing
	multilingual documents led to further, almost intractable problems.
	Unicode (a super-catalog of nearly all writing systems from all of
	the world's languages) was created to work around this problem. One
	of Unicode's encodings, UTF-8, retains all 128 ASCII symbols (7-bit
	codes), but handles other characters differently. Those are preceded
	by a specific escape sequence of a few bits, which implicitly
	defines the length of the character. This allows encoding all
	Unicode characters on a sequence of one or more bytes. Its use
	has been popularized by the fact that it's the default encoding
	in XML documents.</para>
        <indexterm><primary>ASCII</primary></indexterm>
        <indexterm><primary>UTF-8</primary></indexterm>
        <indexterm><primary>Unicode</primary></indexterm>

	<para>This is the encoding that should generally be used,
	and is thus the default on Debian systems.</para>
      </sidebar>

      <para>The <emphasis role="pkg">locales</emphasis> package includes
      all the elements required for proper functioning of
      “localization” of various applications. During installation,
      this package will ask to select a set of supported
      languages. This set can be changed at any time by running
      <command>dpkg-reconfigure locales</command> as root.</para>

      <para>The first question invites you to select “locales” to
      support. Selecting all English locales (meaning those beginning
      with “<literal>en_US</literal>”) is a reasonable choice. Do not
      hesitate to choose other locales if the machine will host foreign
      users. The list of locales enabled on the system is stored in the
      <filename>/etc/locale.gen</filename> file. It is possible to edit
      this file by hand, but you should run <command>locale-gen</command>
      after any modifications. It will generate the necessary files for the
      added locales to work, and remove any obsolete files.</para>

      <para>The second question, entitled “Default locale for the system environment”,
      requests a default locale. The recommended choice in the U.S.A. is
      “<literal>en_US.UTF-8</literal>”. British English speakers will
      prefer “<literal>en_GB.UTF-8</literal>”, and Canadians will
      prefer either “<literal>en_CA.UTF-8</literal>” or, for French,
      “<literal>fr_CA.UTF-8</literal>”. The
      <filename>/etc/default/locale</filename> file will then be modified
      to store this choice. From there, it's picked up by all user sessions
      since PAM will inject its content in the <varname>LANG</varname>
      environment variable.</para>
      <indexterm><primary>environment</primary></indexterm>
      <indexterm><primary>locale</primary></indexterm>
      <indexterm><primary><varname>LANG</varname></primary></indexterm>

      <sidebar id="sidebar.intro-pam">
        <title><emphasis>BEHIND THE SCENES</emphasis> <filename>/etc/environment</filename> and <filename>/etc/default/locale</filename></title>

	<para>The <filename>/etc/environment</filename> file provides the
	<command>login</command>, <command>gdm</command>, or even
	<command>ssh</command> programs with the correct environment
	variables to be created.</para>

	<para>These applications do not create these variables directly,
	but rather via a PAM (<filename>pam_env.so</filename>) module. PAM
	(Pluggable Authentication Module) is a modular library centralizing
	the mechanisms for authentication, session initialization, and
	password management. See <xref linkend="sect.config-pam"/> for
	an example of PAM configuration.</para>

	<para>The <filename>/etc/default/locale</filename> file works in a
	similar manner, but contains only the <varname>LANG</varname>
	environment variable. Thanks to this split, some PAM users can inherit
	a complete environment without localization. Indeed, it's generally
	discouraged to run server programs with localization enabled;
	on the other hand, localization and regional settings are recommended
	for programs that open user sessions.</para>
        <indexterm><primary>PAM</primary></indexterm>
        <indexterm><primary><filename>pam_env.so</filename></primary></indexterm>
      </sidebar>
    </section>

    <section id="sect.keyboard-config">
      <title>Configuring the Keyboard</title>
      <indexterm><primary>keyboard layout</primary></indexterm>
      <indexterm><primary>layout, keyboard</primary></indexterm>

      <para>Even if the keyboard layout is managed differently
      in console and graphical mode, Debian offers a single
      configuration interface that works for both: it's based on debconf
      and is implemented in the <emphasis
      role="pkg">keyboard-configuration</emphasis> package. Thus the
      <command>dpkg-reconfigure keyboard-configuration</command> command
      can be used at any time to reset the keyboard layout.</para>

      <indexterm><primary><emphasis>console-data</emphasis></primary></indexterm>
      <indexterm><primary><emphasis>console-tools</emphasis></primary></indexterm>
      <indexterm><primary><emphasis>keyboard-configuration</emphasis></primary></indexterm>

      <para><indexterm><primary><literal>azerty</literal></primary></indexterm>The
      questions are relevant to the physical keyboard layout (a standard PC
      keyboard in the US will be a “Generic 104 key”), then the layout
      to choose (generally “US”), and then the position of the AltGr
      key (right Alt). Finally comes the question of the key to use for the
      “Compose key”, which allows for entering special characters by
      combining keystrokes. Type successively <keycombo
      action="seq"><keycap>Compose</keycap><keycap>'</keycap><keycap>e</keycap></keycombo>
      and produce an e-acute (“é”). All these combinations are
      described in the
      <filename>/usr/share/X11/locale/en_US.UTF-8/Compose</filename> file
      (or another file, determined according to the current locale
      indicated by <filename>/usr/share/X11/locale/compose.dir</filename>).
      </para>
      <indexterm><primary><literal>Compose</literal>, key</primary></indexterm>
      <indexterm><primary><literal>Meta</literal>, key</primary></indexterm>
      <indexterm><primary>key</primary><secondary><literal>Meta</literal></secondary></indexterm>
      <indexterm><primary>key</primary><secondary><literal>Compose</literal></secondary></indexterm>

      <para>Note that the keyboard configuration for graphical mode
      described here only affects the default layout; the GNOME and KDE
      environments, among others, provide a keyboard control panel in their
      preferences allowing each user to have their own configuration. Some
      additional options regarding the behavior of some particular keys are
      also available in these control panels.</para>


    </section>
    <section id="sect.utf8-migration">
      <title>Migrating to UTF-8</title>

      <para>The generalization of UTF-8 encoding has been a long awaited
      solution to numerous difficulties with interoperability, since it
      facilitates international exchange and removes the arbitrary limits
      on characters that can be used in a document. The one drawback is
      that it had to go through a rather difficult transition phase. Since
      it could not be completely transparent (that is, it could not happen
      at the same time all over the world), two conversion operations
      were required: one on file contents, and the other on filenames.
      Fortunately, the bulk of this migration has been completed and we
      discuss it largely for reference.</para>

      <sidebar>
        <title><emphasis>CULTURE</emphasis> <foreignphrase>Mojibake</foreignphrase> and interpretation errors</title>

	<para>When a text is sent (or stored) without encoding information,
	it is not always possible for the recipient to know with certainty
	what convention to use for determining the meaning of a set of
	bytes. You can usually get an idea by getting statistics on the
	distribution of values present in the text, but that doesn't always
	give a definite answer. When the encoding system chosen for reading
	differs from that used in writing the file, the bytes are
	mis-interpreted, and you get, at best, errors on some characters,
	or, at worst, something completely illegible.</para>

	<para>Thus, if a French text appears normal with the exception of
	accented letters and certain symbols which appear to be replaced
	with sequences of characters like “Ã©” or Ã¨” or
	“Ã§”, it is probably a file encoded as UTF-8 but interpreted
	as ISO-8859-1 or ISO-8859-15. This is a sign of a local
	installation that has not yet been migrated to UTF-8. If, instead,
	you see question marks instead of accented letters — even if
	these question marks seem to also replace a character that should
	have followed the accented letter — it is likely that your
	installation is already configured for UTF-8 and that you have been
	sent a document encoded in Western ISO.</para>

	<para>So much for “simple” cases. These cases only appear in
	Western culture, since Unicode (and UTF-8) was designed to maximize
	the common points with historical encodings for Western languages
	based on the Latin alphabet, which allows recognition of parts of
	the text even when some characters are missing.</para>

	<para>In more complex configurations, which, for example, involve
	two environments corresponding to two different languages that do
	not use the same alphabet, you often get completely illegible
	results — a series of abstract symbols that have nothing to do
	with each other. This is especially common with Asian languages due
	to their numerous languages and writing systems. The Japanese word
	<foreignphrase>mojibake</foreignphrase> has been adopted to
	describe this phenomenon. When it appears, diagnosis is more
	complex and the simplest solution is often to simply migrate to
	UTF-8 on both sides.</para>
      </sidebar>

      <para>As far as file names are concerned, the migration can be
      relatively simple. The <command>convmv</command> tool (in the package
      with the same name) was created specifically for this purpose; it
      allows renaming files from one encoding to another. The use of this
      tool is relatively simple, but we recommend doing it in two steps to
      avoid surprises. The following example illustrates a UTF-8
      environment containing directory names encoded in ISO-8859-15, and
      the use of <command>convmv</command> to rename them.</para>

      <screen><computeroutput>$ </computeroutput><userinput>ls travail/</userinput>
<computeroutput>Ic?nes  ?l?ments graphiques  Textes
$ </computeroutput><userinput>convmv -r -f iso-8859-15 -t utf-8 travail/</userinput>
<computeroutput>Starting a dry run without changes...
mv "travail/�l�ments graphiques"        "travail/Éléments graphiques"
mv "travail/Ic�nes"     "travail/Icônes"
No changes to your files done. Use --notest to finally rename the files.
$ </computeroutput><userinput>convmv -r --notest -f iso-8859-15 -t utf-8 travail/</userinput>
<computeroutput>mv "travail/�l�ments graphiques"        "travail/Éléments graphiques"
mv "travail/Ic�nes"     "travail/Icônes"
Ready!
$ </computeroutput><userinput>ls travail/</userinput>
<computeroutput>Éléments graphiques  Icônes  Textes</computeroutput>
</screen>

      <para>For the file content, conversion procedures are more complex
      due to the vast variety of existing file formats. Some file formats
      include encoding information that facilitates the tasks of the
      software used to treat them; it is sufficient, then, to open these
      files and re-save them specifying UTF-8 encoding. In other cases, you
      have to specify the original encoding (ISO-8859-1 or “Western”,
      or ISO-8859-15 or “Western (Euro)”, according to the
      formulations) when opening the file.</para>

      <para>For simple text files, you can use <command>recode</command>
      (in the package of the same name) which allows automatic recoding.
      This tool has numerous options so you can play with its behavior. We
      recommend you consult the documentation, the <citerefentry>
      <refentrytitle>recode</refentrytitle> <manvolnum>1</manvolnum>
      </citerefentry> man page, or the <citerefentry>
      <refentrytitle>recode</refentrytitle> </citerefentry> info page (more
      complete).</para>
    </section>
  </section>
  <section id="sect.network-config">
    <title>Configuring the Network</title>

    <sidebar id="sidebar.networking-basics">
      <title><emphasis>BACK TO BASICS</emphasis> Essential network concepts (Ethernet, IP address, subnet, broadcast).</title>
      <indexterm><primary>Ethernet</primary></indexterm>
      <indexterm><primary>10BASE-T</primary></indexterm>
      <indexterm><primary>100BASE-T</primary></indexterm>
      <indexterm><primary>1000BASE-T</primary></indexterm>
      <indexterm><primary>10GBASE-T</primary></indexterm>
      <indexterm><primary>connector, RJ45</primary></indexterm>
      <indexterm><primary>RJ45 connector</primary></indexterm>

      <para>Most modern local networks use the Ethernet protocol, where
      data is split into small blocks called frames and transmitted on the
      wire one frame at a time. Data speeds vary from 10 Mb/s for older
      Ethernet cards to 10 Gb/s in the newest cards (with the most common
      rate currently growing from 100 Mb/s to 1 Gb/s). The most widely
      used cables are called 10BASE-T, 100BASE-T, 1000BASE-T or 10GBASE-T
      depending on the throughput they can reliably provide (the T stands
      for “twisted pair”); those cables end in an RJ45 connector. There
      are other cable types, used mostly for speeds above
      1 Gb/s.</para>

      <indexterm><primary>address, IP address</primary></indexterm>
      <indexterm><primary>IP address</primary></indexterm>

      <para>An IP address is a number used to identify a network interface
      on a computer on a local network or the Internet. In the currently
      most widespread version of IP (IPv4), this number is encoded in 32
      bits, and is usually represented as 4 numbers separated by periods
      (e.g. <literal>192.168.0.1</literal>), each number being between 0
      and 255 (inclusive, which corresponds to 8 bits of data). The next
      version of the protocol, IPv6, extends this addressing space to 128
      bits, and the addresses are generally represented as series of
      hexadecimal numbers separated by colons (e.g.,
      2001:0db8:13bb:0002:0000:0000:0000:0020, or 2001:db8:13bb:2::20 for
      short).</para>

      <indexterm><primary>subnet</primary></indexterm>
      <indexterm><primary>mask</primary><secondary>subnet mask</secondary></indexterm>
      <indexterm><primary>network</primary><secondary>address</secondary></indexterm>

      <para>A subnet mask (netmask) defines in its binary code which
      portion of an IP address corresponds to the network, the remainder
      specifying the machine. In the example of configuring a static IPv4
      address given here, the subnet mask, <literal>255.255.255.0</literal>
      (24 “1”s followed by 8 “0”s in binary representation)
      indicates that the first 24 bits of the IP address correspond to the
      network address, and the other 8 are specific to the machine. In
      IPv6, for readability, only the number of “1”s is expressed; the
      netmask for an IPv6 network could, thus, be
      <literal>64</literal>.</para>

      <para>The network address is an IP address in which the part
      describing the machine's number is 0. The range of IPv4 addresses in
      a complete network is often indicated by the syntax,
      <emphasis>a.b.c.d/e</emphasis>, in which <emphasis>a.b.c.d</emphasis>
      is the network address and <emphasis>e</emphasis> is the number of
      bits affected to the network part in an IP address. The example
      network would thus be written: <literal>192.168.0.0/24</literal>. The
      syntax is similar in IPv6:
      <literal>2001:db8:13bb:2::/64</literal>.</para>

      <indexterm><primary>router</primary></indexterm>
      <indexterm><primary>bridge</primary></indexterm>

      <para>A router is a machine that connects several networks to each
      other. All traffic coming through a router is guided to the correct
      network. To do this, the router analyzes incoming packets and
      redirects them according to the IP address of their destination. The
      router is often known as a gateway; in this configuration, it works
      as a machine that helps reach out beyond a local network (towards an
      extended network, such as the Internet).</para>

      <indexterm><primary>broadcast</primary></indexterm>

      <para>The special broadcast address connects all the stations in a
      network. Almost never “routed”, it only functions on the network
      in question. Specifically, it means that a data packet addressed to
      the broadcast never passes through the router.</para>

      <para>This chapter focuses on IPv4 addresses, since they are
      currently the most commonly used. The details of the IPv6 protocol
      are approached in <xref linkend="sect.ipv6"/>, but the concepts
      remain the same.</para>
    </sidebar>

    <para>Since the network is automatically configured during the initial
    installation, the <filename>/etc/network/interfaces</filename> file
    already contains a valid configuration. A line starting with
    <literal>auto</literal> gives a list of interfaces to be automatically
    configured on boot by <emphasis role="pkg">ifupdown</emphasis> and
    its <filename>/etc/init.d/networking</filename> init script.
    This will often be <literal>eth0</literal>, which
    refers to the first Ethernet card.</para>

    <indexterm><primary>network</primary><secondary>configuration</secondary></indexterm>
    <indexterm><primary>configuration</primary><secondary>of the network</secondary></indexterm>
    <indexterm><primary>interface</primary><secondary>network interface</secondary></indexterm>
    <indexterm><primary><literal>eth0</literal></primary></indexterm>

    <sidebar>
      <title><emphasis>ALTERNATIVE</emphasis> NetworkManager</title>
      <indexterm><primary><emphasis role="pkg">network-manager</emphasis></primary></indexterm>

      <para>If Network Manager is particularly recommended in roaming setups
      (see <xref linkend="sect.roaming-network-config" />),
      it's also perfectly usable as the default network management
      tool. You can create “System connections” that are used as soon
      as the computer boots either manually with a
      <filename>.ini</filename>-like file in
      <filename>/etc/NetworkManager/system-connections/</filename> or
      through a graphical tool (<command>nm-connection-editor</command>).
      Just remember to deactivate all entries in
      <filename>/etc/network/interfaces</filename> if you want
      Network Manager to handle them.
      <ulink type="block" url="http://wiki.gnome.org/NetworkManager/SystemSettings"/>
      <ulink type="block" url="http://projects.gnome.org/NetworkManager/developers/api/09/ref-settings.html"/>
      </para>
    </sidebar>

    <section id="sect.interface-ethernet">
      <title>Ethernet Interface</title>

      <para>If the computer has an Ethernet card, the IP network that is
      associated with it must be configured by choosing from one of two
      methods. The simplest method is dynamic configuration with DHCP, and
      it requires a DHCP server on the local network. It may indicate a
      desired hostname, corresponding to the <literal>hostname</literal>
      setting in the example below. The DHCP server then sends
      configuration settings for the appropriate network.
      </para>

      <indexterm><primary>Ethernet</primary></indexterm>
      <indexterm><primary>DHCP</primary></indexterm>

      <example id="example.config-dhcp">
        <title>DHCP configuration</title>

        <programlisting>
auto eth0
iface eth0 inet dhcp
  hostname arrakis
</programlisting>
      </example>

      <para>A “static” configuration must indicate network settings in
      a fixed manner. This includes at least the IP address and subnet
      mask; network and broadcast addresses are also sometimes listed. A
      router connecting to the exterior will be specified as a
      gateway.</para>

      <example id="example.static-network">
        <title>Static configuration</title>

        <programlisting>
auto eth0
iface eth0 inet static
  address 192.168.0.3
  netmask 255.255.255.0
  broadcast 192.168.0.255
  network 192.168.0.0
  gateway 192.168.0.1
</programlisting>
      </example>

      <sidebar>
        <title><emphasis>NOTE</emphasis> Multiple addresses</title>

	<para>It is possible not only to associate several interfaces to a
	single, physical network card, but also several IP addresses to a
	single interface. Remember also that an IP address may correspond
	to any number of names via DNS, and that a name may also correspond
	to any number of numerical IP addresses.</para>

	<para>As you can guess, the configurations can be rather complex,
	but these options are only used in very special cases. The examples
	cited here are typical of the usual configurations.</para>
      </sidebar>
    </section>
    <section id="sect.ppp-rtc">
      <title>Connecting with PPP through a PSTN Modem</title>
      <indexterm><primary>PPP</primary></indexterm>
      <indexterm><primary>point to point</primary></indexterm>
      <indexterm><primary>connection</primary><secondary>by PSTN modem</secondary></indexterm>
      <indexterm><primary>modem</primary><secondary>PSTN</secondary></indexterm>

      <para>A point to point (PPP) connection establishes an intermittent
      connection; this is the most common solution for connections made
      with a telephone modem (“PSTN modem”, since the connection goes
      over the public switched telephone network).</para>

      <para>A connection by telephone modem requires an account with an
      access provider, including a telephone number, username, password,
      and, sometimes the authentication protocol to be used. Such a
      connection is configured using the <command>pppconfig</command> tool
      in the Debian package of the same name. By default, it sets up a
      connection named <literal>provider</literal> (as in Internet service
      provider). When in doubt about the authentication
      protocol, choose <emphasis>PAP</emphasis>: it is offered by the
      majority of Internet service providers.</para>

      <indexterm><primary><command>pppconfig</command></primary></indexterm>
      <indexterm><primary>PAP</primary></indexterm>

      <para>After configuration, it is possible to connect using the
      <command>pon</command> command (giving it the name of the connection
      as a parameter, when the default value of <literal>provider</literal>
      is not appropriate). The link is disconnected with the
      <command>poff</command> command. These two commands can be executed
      by the root user, or by any other user, provided they are in the
      <literal>dip</literal> group.</para>

      <indexterm><primary><command>pon</command></primary></indexterm>
      <indexterm><primary><command>poff</command></primary></indexterm>

      <sidebar>
        <title><emphasis>TOOL</emphasis> On-demand connection with <command>diald</command></title>
        <indexterm><primary><command>diald</command></primary></indexterm>
        <indexterm><primary>connection</primary><secondary>on demand</secondary></indexterm>

	<para><command>diald</command> is an on-demand connection service
	that automatically establishes a connection when needed, by
	detecting an outgoing IP packet and disconnecting after a period of
	inactivity.</para>
      </sidebar>
    </section>
    <section id="sect.adsl">
      <title>Connecting through an ADSL Modem</title>
      <indexterm><primary>connection</primary><secondary>by ADSL modem</secondary></indexterm>
      <indexterm><primary>modem</primary><secondary>ADSL</secondary></indexterm>
      <indexterm><primary>ADSL, modem</primary></indexterm>

      <para>The generic term “ADSL modem” covers a multitude of devices
      with very different functions. The modems that are simplest to use
      with Linux are those that have an Ethernet interface (and not only a
      USB interface). These tend to be popular; most ADSL Internet service
      providers lend (or lease) a “box” with Ethernet interfaces.
      Depending on the type of modem, the configuration required can vary
      widely.</para>
      <section id="sect.adsl-pppoe">
        <title>Modems Supporting PPPOE</title>
        <indexterm><primary>PPPOE</primary></indexterm>
        <indexterm><primary><command>pppoeconf</command></primary></indexterm>

	<para>Some Ethernet modems work with the PPPOE protocol (Point to
	Point Protocol over Ethernet). The <command>pppoeconf</command>
	tool (from the package with the same name) will configure the
	connection. To do so, it modifies the
	<filename>/etc/ppp/peers/dsl-provider</filename> file with the
	settings provided and records the login information in the
	<filename>/etc/ppp/pap-secrets</filename> and
	<filename>/etc/ppp/chap-secrets</filename> files. It is recommended
	to accept all modifications that it proposes.</para>

	<para>Once this configuration is complete, you can open the ADSL
	connection with the command, <command>pon dsl-provider</command>
	and disconnect with <command>poff dsl-provider</command>.</para>
        <indexterm><primary><literal>dsl-provider</literal></primary></indexterm>

        <sidebar>
          <title><emphasis>TIP</emphasis> Starting <command>ppp</command> via <command>init</command></title>
          <indexterm><primary><command>init</command></primary></indexterm>

	  <para>PPP connections over ADSL are, by definition, intermittent.
	  Since they are usually not billed according to time, there are few
	  downsides to the temptation of keeping them always open; one
	  simple means to do so is to use the <command>init</command>
	  process to control the connection. All that's needed is to add a
	  line such as the following at the end of the
	  <filename>/etc/inittab</filename> file; then, any time the
	  connection is disconnected, <command>init</command> will
	  reconnect it.</para>

          <programlisting>
adsl:2345:respawn:/usr/sbin/pppd call dsl-provider
</programlisting>

	  <para>Most ADSL connections disconnect on a daily basis, but this
	  method reduces the duration of the interruption.</para>
        </sidebar>
      </section>
      <section id="sect.adsl-pptp">
        <title>Modems Supporting PPTP</title>
        <indexterm><primary>PPTP</primary></indexterm>

	<para>The PPTP (Point-to-Point Tunneling Protocol) protocol was
	created by Microsoft. Deployed at the beginning of ADSL, it was
	quickly replaced by PPPOE. If this protocol is forced on you, see
	<xref linkend="network-infrastructure"/> in the section about
	virtual private networks detailing PPTP.</para>
      </section>
      <section id="sect.adsl-dhcp">
        <title>Modems Supporting DHCP</title>

	<para>When a modem is connected to the computer by an Ethernet
	cable (crossover cable) you typically configure a network
	connection by DHCP on the computer; the modem automatically acts as
	a gateway by default and takes care of routing (meaning that it
	manages the network traffic between the computer and the
	Internet).</para>

        <sidebar>
          <title><emphasis>BACK TO BASICS</emphasis> Crossover cable for a direct Ethernet connection</title>
          <indexterm><primary>crossover cable</primary></indexterm>

	  <para>Computer network cards expect to receive data on specific
	  wires in the cable, and send their data on others. When you
	  connect a computer to a local network, you usually connect a
	  cable (straight or crossover) between the network card and a
	  repeater or switch. However, if you want to connect two computers
	  directly (without an intermediary switch or repeater), you must
	  route the signal sent by one card to the receiving side of the
	  other card, and vice-versa. This is the purpose of a crossover
	  cable, and the reason it is used.</para>

          <para>Note that this distinction is becoming less relevant
          over time, as modern network cards are able do detect the
          type of cable present and adapt accordingly, so it won't be
          unusual that both kinds of cable will work in a given
          location.</para>
        </sidebar>

	<para>Most “ADSL routers” on the market can be used like this, as
	do most of the ADSL modems provided by Internet services
	providers.</para>
      </section>
    </section>
    <section id="sect.roaming-network-config">
      <title>Automatic Network Configuration for Roaming Users</title>
      <indexterm><primary><emphasis role="pkg">network-manager</emphasis></primary></indexterm>
      <indexterm><primary>network</primary><secondary>roaming configuration</secondary></indexterm>

      <para>Many Falcot engineers have a laptop computer that, for
      professional purposes, they also use at home. The network
      configuration to use differs according to location. At home, it may
      be a wifi network (protected by a WEP key), while the workplace uses
      a wired network for greater security and more bandwidth.</para>

      <para>To avoid having to manually connect or disconnect the
      corresponding network interfaces, administrators installed the
      <emphasis role="pkg">network-manager</emphasis> package on these
      roaming machines. This software enables a user to easily switch from
      one network to another using a small icon displayed in the
      notification area of their graphical desktop. Clicking on this icon
      displays a list of available networks (both wired and wireless), so
      they can simply choose the network they wish to use. The program
      saves the configuration for the networks to which the user has
      already connected, and automatically switches to the best available
      network when the current connection drops.</para>

      <para>In order to do this, the program is structured in two parts: a
      daemon running as root handles activation and configuration of
      network interfaces and a user interface controls this daemon. PolicyKit
      handles the required authorizations to control this program and Debian
      configured PolicyKit in such a way so that members of the netdev
      group can add or change Network Manager connections.
      </para>

      <para>Network Manager knows how to handle various types of
      connections (DHCP, manual configuration, local network), but only if
      the configuration is set with the program itself. This is why it will
      systematically ignore all network interfaces in
      <filename>/etc/network/interfaces</filename> for which it is not
      suited. Since Network Manager doesn't give details when no network
      connections are shown, the easy way is to delete from
      <filename>/etc/network/interfaces</filename> any configuration for
      all interfaces that must be managed by Network Manager.</para>

      <para>Note that this program is installed by default when the
      “Desktop Environment” task is chosen during initial
      installation.</para>

      <sidebar>
        <title><emphasis>ALTERNATIVE</emphasis> Configuration by “network profile”</title>
        <indexterm><primary><emphasis role="pkg">guessnet</emphasis></primary></indexterm>

	<para>More advanced users may want to try the <emphasis
	role="pkg">guessnet</emphasis> package for automatic network
	configuration. A group of test scripts determine which network
	profile should be activated and configure it on the fly.</para>

	<para>Users who prefer to manually select a network profile will
	prefer the <emphasis role="pkg">netenv</emphasis> program, found in
	the package of the same name.</para>
      </sidebar>
    </section>
  </section>
  <section id="sect.hostname-name-service">
    <title>Setting the Hostname and Configuring the Name Service</title>
    <indexterm><primary>name</primary><secondary>attribution and resolution</secondary></indexterm>
    <indexterm><primary>assignment of names</primary></indexterm>

    <para>The purpose of assigning names to IP numbers is to make them
    easier for people to remember. In reality, an IP address identifies a
    network interface associated with a device such as a network card.
    Since each machine can have several network cards, and several
    interfaces on each card, one single computer can have several names in
    the domain name system.</para>

    <para>Each machine is, however, identified by a main (or
    “canonical”) name, stored in the <filename>/etc/hostname</filename>
    file and communicated to the Linux kernel by initialization scripts
    through the <command>hostname</command> command. The current value is
    available in a virtual filesystem, and you can get it with the
    <command>cat /proc/sys/kernel/hostname</command> command.</para>

    <indexterm><primary><command>hostname</command></primary></indexterm>

    <sidebar>
      <title><emphasis>BACK TO BASICS</emphasis> <filename>/proc/</filename> and <filename>/sys/</filename>, virtual filesystems</title>
      <indexterm><primary><filename>/proc/</filename></primary></indexterm>
      <indexterm><primary><filename>proc</filename></primary></indexterm>
      <indexterm><primary><filename>/sys/</filename></primary></indexterm>
      <indexterm><primary><filename>sys</filename></primary></indexterm>

      <para>The <filename>/proc/</filename> and <filename>/sys/</filename>
      file trees are generated by “virtual” filesystems. This is a
      practical means of recovering information from the kernel (by listing
      virtual files) and communicating them to it (by writing to virtual
      files).</para>

      <para><filename>/sys/</filename> in particular is designed to provide
      access to internal kernel objects, especially those representing the
      various devices in the system. The kernel can, thus, share various
      pieces of information: the status of each device (for example, if it
      is in energy saving mode), whether it is a removable device, etc.
      Note that <filename>/sys/</filename> has only existed since kernel
      version 2.6.</para>
    </sidebar>

    <para>Surprisingly, the domain name is not managed in the same way, but
    comes from the complete name of the machine, acquired through name
    resolution. You can change it in the <filename>/etc/hosts</filename>
    file; simply write a complete name for the machine there at the
    beginning of the list of names associated with the address of the
    machine, as in the following example:</para>
    <informalexample>
      <programlisting>
127.0.0.1     localhost
192.168.0.1   arrakis.falcot.com arrakis
</programlisting>
    </informalexample>
    <indexterm><primary><filename>hosts</filename></primary></indexterm>
    <indexterm><primary><filename>/etc/hosts</filename></primary></indexterm>
    <indexterm><primary>domain</primary><secondary>name</secondary></indexterm>
    <indexterm><primary>name</primary><secondary>domain</secondary></indexterm>
    <indexterm><primary>NSS</primary></indexterm>
    <section id="sect.name-resolution">
      <title>Name Resolution</title>
      <indexterm><primary>resolution</primary><secondary>name</secondary></indexterm>
      <indexterm><primary>name</primary><secondary>resolution</secondary></indexterm>

      <para>The mechanism for name resolution in Linux is modular and can
      use various sources of information declared in the
      <filename>/etc/nsswitch.conf</filename> file. The entry that involves
      host name resolution is <literal>hosts</literal>. By default, it
      contains <literal>files dns</literal>, which means that the system
      consults the <filename>/etc/hosts</filename> file first, then DNS
      servers. NIS/NIS+ or LDAP servers are other possible sources.</para>

      <sidebar>
        <title><emphasis>NOTE</emphasis> NSS and DNS</title>

	<para>Be aware that the commands specifically intended to query DNS
	(especially <command>host</command>) do not use the standard name
	resolution mechanism (NSS). As a consequence, they do not take into
	consideration <filename>/etc/nsswitch.conf</filename>, and thus,
	not <filename>/etc/hosts</filename> either.</para>
      </sidebar>
      <section id="sect.dns-server-configuration">
        <title>Configuring DNS Servers</title>
        <indexterm><primary>DNS</primary></indexterm>
        <indexterm><primary>Domain Name Service</primary></indexterm>

	<para>DNS (Domain Name Service) is a distributed and hierarchical
	service mapping names to IP addresses, and vice-versa.
	Specifically, it can turn a human-friendly name such as
	<literal>www.eyrolles.com</literal> into the actual IP address,
	<literal>213.244.11.247</literal>.</para>

	<para>To access DNS information, a DNS server must be available to
	relay requests. Falcot Corp has its own, but an individual user is
	more likely to use the DNS servers provided by their ISP.</para>

        <indexterm><primary><filename>resolv.conf</filename></primary></indexterm>
        <indexterm><primary><literal>nameserver</literal></primary></indexterm>

	<para>The DNS servers to be used are indicated in the
	<filename>/etc/resolv.conf</filename>, one per line, with the
	<literal>nameserver</literal> keyword preceding an IP address, as
	in the following example:</para>

        <programlisting>
nameserver 212.27.32.176
nameserver 212.27.32.177
nameserver 8.8.8.8
</programlisting>
      </section>
      <section id="sect.etc-hosts">
        <title>The <filename>/etc/hosts</filename> file</title>
        <indexterm><primary><filename>hosts</filename></primary></indexterm>
        <indexterm><primary><filename>/etc/hosts</filename></primary></indexterm>

	<para>If there is no name server on the local network, it is still
	possible to establish a small table mapping IP addresses and
	machine hostnames in the <filename>/etc/hosts</filename> file,
	usually reserved for local network stations. The syntax of this
	file is very simple: each line indicates a specific IP address
	followed by the list of any associated names (the first being
	“completely qualified”, meaning it includes the domain
	name).</para>

	<para>This file is available even during network outages or when
	DNS servers are unreachable, but will only really be useful when
	duplicated on all the machines on the network. The slightest
	alteration in correspondence will require the file to be updated
	everywhere. This is why <filename>/etc/hosts</filename> generally
	only contains the most important entries.</para>

	<para>This file will be sufficient for a small network not
	connected to the Internet, but with 5 machines or more, it is
	recommended to install a proper DNS server.</para>

        <sidebar>
          <title><emphasis>TIP</emphasis> Bypassing DNS</title>

	  <para>Since applications check the
	  <filename>/etc/hosts</filename> file before querying DNS, it is
	  possible to include information in there that is different from
	  what the DNS would return, and therefore to bypass normal
	  DNS-based name resolution.</para>

	  <para>This allows, in the event of DNS changes not yet
	  propagated, to test access to a website with the intended name
	  even if this name is not properly mapped to the correct IP
	  address yet.</para>

	  <para>Another possible use is to redirect traffic intended for a
	  specific host to the localhost, thus preventing any
	  communication with the given host. For example, hostnames of
	  servers dedicated to serving ads could be diverted which would
	  bypass these ads resulting in more fluid, less distracting,
	  navigation.</para>
        </sidebar>
      </section>
    </section>
  </section>
  <section id="sect.user-group-databases">
    <title>User and Group Databases</title>
    <indexterm><primary>user</primary><secondary>database</secondary></indexterm>
    <indexterm><primary>group</primary><secondary>database</secondary></indexterm>
    <indexterm><primary>database</primary><secondary>of users</secondary></indexterm>
    <indexterm><primary>database</primary><secondary>of groups</secondary></indexterm>

    <para>The list of users is usually stored in the
    <filename>/etc/passwd</filename> file, while the
    <filename>/etc/shadow</filename> file stores encrypted passwords. Both
    are text files, in a relatively simple format, which can be read and
    modified with a text editor. Each user is listed there on a line with
    several fields separated with a colon
    (“<literal>:</literal>”).</para>

    <sidebar>
      <title><emphasis>NOTE</emphasis> Editing system files</title>

      <para>The system files mentioned in this chapter are all plain text
      files, and can be edited with a text editor. Considering their
      importance to core system functionality, it is always a good idea to
      take extra precautions when editing system files. First, always make
      a copy or backup of a system file before opening or altering it.
      Second, on servers or machines where more than one person could
      potentially access the same file at the same time, take extra steps
      to guard against file corruption.</para>

      <para>For this purpose, it is enough to use the
      <command>vipw</command> command to edit the
      <filename>/etc/passwd</filename> file, or <command>vigr</command> to
      edit <filename>/etc/group</filename>. These commands lock the file in
      question prior to running the text editor, (<command>vi</command> by
      default, unless the <varname>EDITOR</varname> environment variable
      has been altered). The <literal>-s</literal> option in these commands
      allows editing the corresponding
      <foreignphrase>shadow</foreignphrase> file.</para>
    </sidebar>

    <sidebar>
      <title><emphasis>BACK TO BASICS</emphasis> Crypt, a one-way function</title>
      <indexterm><primary>crypt</primary></indexterm>

      <para><command>crypt</command> is a one-way function that transforms
      a string (<varname>A</varname>) into another string
      (<varname>B</varname>) in a way that <varname>A</varname> cannot be
      derived from <varname>B</varname>. The only way to identify
      <varname>A</varname> is to test all possible values, checking each
      one to determine if transformation by the function will produce
      <varname>B</varname> or not. It uses up to 8 characters as input
      (string <varname>A</varname>) and generates a string of 13,
      printable, ASCII characters (string <varname>B</varname>).</para>
    </sidebar>
    <section id="sect.etc-passwd">
      <title>User List: <filename>/etc/passwd</filename></title>

      <para>Here is the list of fields in the
      <filename>/etc/passwd</filename> file:</para>
      <indexterm><primary><command>passwd</command></primary></indexterm>
      <indexterm><primary><filename>/etc/passwd</filename></primary></indexterm>
      <indexterm><primary><literal>uid</literal></primary></indexterm>
      <indexterm><primary><literal>gid</literal></primary></indexterm>
      <indexterm><primary><literal>GECOS</literal></primary></indexterm>
      <indexterm><primary><literal>login</literal></primary></indexterm>
      <itemizedlist>
        <listitem>
	  <para>login, for example <literal>rhertzog</literal>;</para>
        </listitem>
        <listitem>
	  <para>password: this is a password encrypted by a one-way
	  function (<command>crypt</command>), relying on <literal>DES</literal>,
	  <literal>MD5</literal>, <literal>SHA-256</literal> or
	  <literal>SHA-512</literal>. The special value
	  “<literal>x</literal>” indicates that the encrypted password
	  is stored in <filename>/etc/shadow</filename>;</para>
        </listitem>
        <listitem>
	  <para><literal>uid</literal>: unique number identifying each
	  user;</para>
        </listitem>
        <listitem>
	  <para><literal>gid</literal>: unique number for the user's main
	  group (Debian creates a specific group for each user by
	  default);</para>
        </listitem>
        <listitem>
	  <para><literal>GECOS</literal>: data field usually containing the
	  user's full name;</para>
        </listitem>
        <listitem>
	  <para>login directory, assigned to the user for storage of their
	  personal files (the environment variable <varname>$HOME</varname>
	  generally points here);</para>
        </listitem>
        <listitem>
	  <para>program to execute upon login. This is usually a command
	  interpreter (shell), giving the user free rein. If you specify
	  <command>/bin/false</command> (which does nothing and returns
	  control immediately), the user can not login.</para>
        </listitem>
      </itemizedlist>

      <sidebar>
        <title><emphasis>BACK TO BASICS</emphasis> Unix group</title>
        <indexterm><primary>group</primary></indexterm>

	<para>A Unix group is an entity including several users so that
	they can easily share files using the integrated permission system
	(by benefiting from the same rights). You can also restrict use of
	certain programs to a specific group.</para>
      </sidebar>
    </section>
    <section id="sect.etc-shadow">
      <title>The Hidden and Encrypted Password File: <filename>/etc/shadow</filename></title>
      <indexterm><primary><filename>shadow</filename></primary></indexterm>
      <indexterm><primary><filename>/etc/shadow</filename></primary></indexterm>

      <para>The <filename>/etc/shadow</filename> file contains the
      following fields:</para>
      <itemizedlist>
        <listitem>
	  <para>login;</para>
        </listitem>
        <listitem>
	  <para>encrypted password;</para>
        </listitem>
        <listitem>
	  <para>several fields managing password expiration.</para>
        </listitem>
      </itemizedlist>

      <sidebar>
        <title><emphasis>DOCUMENTATION</emphasis> <filename>/etc/passwd</filename>, <filename>/etc/shadow</filename> and <filename>/etc/group</filename> file formats</title>

	<para>These formats are documented in the following man pages:
	<citerefentry><refentrytitle>passwd</refentrytitle><manvolnum>5</manvolnum></citerefentry>,
	<citerefentry><refentrytitle>shadow</refentrytitle><manvolnum>5</manvolnum></citerefentry>,
	and
	<citerefentry><refentrytitle>group</refentrytitle><manvolnum>5</manvolnum></citerefentry>.</para>
      </sidebar>

      <sidebar>
        <title><emphasis>SECURITY</emphasis> <filename>/etc/shadow</filename> file security</title>

	<para><filename>/etc/shadow</filename>, unlike its alter-ego,
	<filename>/etc/passwd</filename>, cannot be read by regular users.
	Any encrypted password stored in <filename>/etc/passwd</filename>
	is readable by anybody; a cracker could try to “break” (or
	reveal) a password by one of several “brute force” methods
	which, simply put, guess at commonly used combinations of
	characters. This attack — called a "dictionary attack" — is no
	longer possible on systems using
	<filename>/etc/shadow</filename>.</para>
      </sidebar>
    </section>
    <section id="sect.account-modification">
      <title>Modifying an Existing Account or Password</title>
      <indexterm><primary><command>chsh</command></primary></indexterm>
      <indexterm><primary><command>chfn</command></primary></indexterm>
      <indexterm><primary><command>passwd</command></primary></indexterm>
      <indexterm><primary><command>chage</command></primary></indexterm>
      <indexterm><primary>password</primary></indexterm>

      <para>The following commands allow modification of the information
      stored in specific fields of the user databases:
      <command>passwd</command> permits a regular user to change their
      password, which in turn, updates the <filename>/etc/shadow</filename>
      file; <command>chfn</command> (CHange Full Name), reserved for the
      super-user (root), modifies the <literal>GECOS</literal> field.
      <command>chsh</command> (CHange SHell) allows the user to change
      their login shell, however available choices will be limited to those
      listed in <filename>/etc/shells</filename>; the administrator, on the
      other hand, is not bound by this restriction and can set the shell to
      any program of their choosing.</para>

      <para>Finally, the <command>chage</command> (CHange AGE) command
      allows the administrator to change the password expiration settings
      (the <literal>-l <replaceable>user</replaceable></literal> option
      will list the current settings). You can also force the expiration of
      a password using the <command>passwd -e
      <replaceable>user</replaceable></command> command, which will require
      the user to change their password the next time they log in.</para>
    </section>
    <section id="sect.disabling-account">
      <title>Disabling an Account</title>
      <indexterm><primary>Disable an account</primary></indexterm>
      <indexterm><primary>account</primary><secondary>disable</secondary></indexterm>

      <para>You may find yourself needing to “disable an account” (lock
      out a user), as a disciplinary measure, for the purposes of an
      investigation, or simply in the event of a prolonged or definitive
      absence of a user. A disabled account means the user cannot login or
      gain access to the machine. The account remains intact on the machine
      and no files or data are deleted; it is simply inaccessible. This is
      accomplished by using the command <command>passwd -l
      <replaceable>user</replaceable></command> (lock). Re-enabling the
      account is done in similar fashion, with the <literal>-u</literal>
      option (unlock).</para>

      <sidebar id="sidebar.intro-nss">
        <title><emphasis>GOING FURTHER</emphasis> NSS and system databases</title>
        <indexterm><primary>NSS</primary></indexterm>
        <indexterm><primary>Name Service Switch</primary></indexterm>

	<para>Instead of using the usual files to manage lists of users and
	groups, you could use other types of databases, such as LDAP or
	<command>db</command>, by using an appropriate NSS (Name Service
	Switch) module. The modules used are listed in the
	<filename>/etc/nsswitch.conf</filename> file, under the
	<literal>passwd</literal>, <literal>shadow</literal> and
	<literal>group</literal> entries. See <xref
	linkend="sect.config-nss"/> for a specific example of the use of
	an NSS module by LDAP.</para>
      </sidebar>
    </section>
    <section id="sect.etc-group">
      <title>Group List: <filename>/etc/group</filename></title>

      <para>Groups are listed in the <filename>/etc/group</filename> file,
      a simple textual database in a format similar to that of the
      <filename>/etc/passwd</filename> file, with the following
      fields:</para>
      <itemizedlist>
        <listitem>
	  <para>group name;</para>
        </listitem>
        <listitem>
	  <para>password (optional): This is only used to join a group when
	  one is not a usual member (with the <command>newgrp</command> or
	  <command>sg</command> commands, see sidebar);</para>
        </listitem>
        <listitem>
	  <para><literal>gid</literal>: unique group identification
	  number;</para>
        </listitem>
        <listitem>
	  <para>list of members: list of names of users who are members of
	  the group, separated by commas.</para>
        </listitem>
      </itemizedlist>

      <para/>

      <sidebar>
        <title><emphasis>BACK TO BASICS</emphasis> Working with several groups</title>
        <indexterm><primary><command>newgrp</command></primary></indexterm>
        <indexterm><primary><command>sg</command></primary></indexterm>
        <indexterm><primary><command>id</command></primary></indexterm>
        <indexterm><primary>group</primary><secondary>change</secondary></indexterm>

	<para>Each user may be a member of many groups; one of them is
	their “main group”. A user's main group is, by default, created
	during initial user configuration. By default, each file that a
	user creates belongs to them, as well as to their main group. This
	is not always desirable; for example, when the user needs to work
	in a directory shared by a group other than their main group. In
	this case, the user needs to change their main group using one of
	the following commands: <command>newgrp</command>, which starts a
	new shell, or <command>sg</command>, which simply executes a
	command using the supplied alternate group. These commands also
	allow the user to join a group to which they do not belong. If the
	group is password protected, they will need to supply the
	appropriate password before the command is executed.</para>

	<para>Alternatively, the user can set the <literal>setgid</literal>
	bit on the directory, which causes files created in that directory
	to automatically belong to the correct group. For more details, see
	sidebar <xref linkend="sidebar.setgid-dir"/>.</para>

	<para>The <command>id</command> command displays the current state
	of a user, with their personal identifier (<varname>uid</varname>
	variable), current main group (<varname>gid</varname> variable),
	and the list of groups to which they belong
	(<varname>groups</varname> variable).</para>
      </sidebar>
      <indexterm><primary><filename>group</filename></primary></indexterm>
      <indexterm><primary><filename>/etc/group</filename></primary></indexterm>

      <para>The <command>addgroup</command> and <command>delgroup</command>
      commands add or delete a group, respectively. The
      <command>groupmod</command> command modifies a group's information
      (its <literal>gid</literal> or identifier). The command
      <command>passwd -g <replaceable>group</replaceable></command> changes
      the password for the group, while the <command>passwd -r -g
      <replaceable>group</replaceable></command> command deletes it.</para>
      <indexterm><primary><command>addgroup</command></primary></indexterm>
      <indexterm><primary><command>delgroup</command></primary></indexterm>
      <indexterm><primary><command>groupmod</command></primary></indexterm>
      <indexterm><primary>group</primary><secondary>creation</secondary></indexterm>
      <indexterm><primary>creation</primary><secondary>of groups</secondary></indexterm>
      <indexterm><primary>group</primary><secondary>deletion</secondary></indexterm>
      <indexterm><primary>deletion of a group</primary></indexterm>

      <sidebar>
        <title><emphasis>TIP</emphasis> <command>getent</command></title>
        <indexterm><primary><command>getent</command></primary></indexterm>

	<para>The <command>getent</command> (get entries) command checks
	the system databases the standard way, using the appropriate
	library functions, which in turn call the NSS modules configured in
	the <filename>/etc/nsswitch.conf</filename> file. The command takes
	one or two arguments: the name of the database to check, and a
	possible search key. Thus, the command <command>getent passwd
	rhertzog</command> will give the information from the user database
	regarding the user <literal>rhertzog</literal>.</para>
      </sidebar>
    </section>
  </section>
  <section id="sect.creating-accounts">
    <title>Creating Accounts</title>
    <indexterm><primary>account</primary><secondary>creation</secondary></indexterm>
    <indexterm><primary>creation</primary><secondary>of user accounts</secondary></indexterm>

    <para>One of the first actions an administrator needs to do when
    setting up a new machine is to create user accounts. This is typically
    done using the <command>adduser</command> command which takes a
    user-name for the new user to be created, as an argument.</para>
    <indexterm><primary><command>adduser</command></primary></indexterm>

    <para>The <command>adduser</command> command asks a few questions
    before creating the account, but its usage is fairly straightforward.
    Its configuration file, <filename>/etc/adduser.conf</filename>,
    includes all the interesting settings: it can be used to automatically
    set a quota for each new user by creating a user template, or to change
    the location of user accounts; the latter is rarely useful, but it
    comes in handy when you have a large number of users and want to divide
    their accounts over several disks, for instance. You can also choose a
    different default shell.</para>

    <sidebar>
      <title><emphasis>BACK TO BASICS</emphasis> Quota</title>
      <indexterm><primary>quota</primary></indexterm>

      <para>The term “quota” refers to a limit on machine resources
      that a user is allowed to use. This frequently refers to disk
      space.</para>
    </sidebar>

    <para>The creation of an account populates the user's home directory
    with the contents of the <filename>/etc/skel/</filename> template. This
    provides the user with a set of standard directories and configuration
    files.</para>
    <indexterm><primary>group</primary><secondary>add a user</secondary></indexterm>
    <indexterm><primary>add a user to a group</primary></indexterm>

    <para>In some cases, it will be useful to add a user to a group (other
    than their default “main” group) in order to grant them additional
    permissions. For example, a user who is included in the
    <emphasis>audio</emphasis> group can access audio devices (see sidebar
    “Device access permissions”). This can be achieved with a
    command such as <command>adduser <replaceable>user</replaceable>
    <replaceable>group</replaceable></command>.</para>

    <sidebar id="sidebar.special-files">
      <title><emphasis>BACK TO BASICS</emphasis> Device access permissions</title>
      <indexterm><primary>device</primary><secondary>access permissions</secondary></indexterm>
      <indexterm><primary>file</primary><secondary>special</secondary></indexterm>
      <indexterm><primary>mode</primary><secondary>character</secondary></indexterm>
      <indexterm><primary>mode</primary><secondary>block</secondary></indexterm>
      <indexterm><primary>block, mode</primary></indexterm>
      <indexterm><primary>character, mode</primary></indexterm>
      <indexterm><primary>special, file</primary></indexterm>
      <indexterm><primary><command>mknod</command></primary></indexterm>

      <para>Each hardware peripheral device is represented under Unix with
      a special file, usually stored in the file tree under
      <filename>/dev/</filename> (DEVices). Two types of special files
      exist according to the nature of the device: “character mode” and
      “block mode” files, each mode allowing for only a limited number
      of operations. While character mode limits interaction with
      read/write operations, block mode also allows seeking within the
      available data. Finally, each special file is associated with two
      numbers (“major” and “minor”) that identify the device to the
      kernel in a unique manner. Such a file, created by the
      <command>mknod</command> command, simply contains a symbolic (and
      more human-friendly) name.</para>

      <para>The permissions of a special file map to the permissions
      necessary to access the device itself. Thus, a file such as
      <filename>/dev/mixer</filename>, representing the audio mixer, only
      has read/write permissions for the root user and members of the
      <literal>audio</literal> group. Only these users can operate the
      audio mixer.</para>

      <para>It should be noted that the combination of <emphasis
      role="pkg">udev</emphasis>, <emphasis
      role="pkg">consolekit</emphasis> and <emphasis
      role="pkg">policykit</emphasis> can add additional permissions to
      allow users physically connected to the console (and not through the
      network) to access to certain devices.</para>
    </sidebar>
  </section>
  <section id="sect.shell-environment">
    <title>Shell Environment</title>

    <para>Command interpreters (or shells) are frequently a user's first
    point of contact with the computer, and they must therefore be rather
    friendly. Most of them use initialization scripts that allow
    configuration of their behavior (automatic completion, prompt text,
    etc.).</para>
    <indexterm><primary>command line interface</primary></indexterm>
    <indexterm><primary>command interpreter</primary></indexterm>
    <indexterm><primary>shell</primary></indexterm>
    <indexterm><primary><command>bash</command></primary></indexterm>

    <para><command>bash</command>, the standard shell, uses the
    <filename>/etc/bash.bashrc</filename> initialization script for
    “interactive” shells, and <filename>/etc/profile</filename> for
    “login” shells.</para>

    <sidebar>
      <title><emphasis>BACK TO BASICS</emphasis> Login shell and (non) interactive shell</title>

      <para>In simple terms, a login shell is invoked when you log in to
      the console either locally or remotely via
      <command>ssh</command>, or when you run an explicit <command>bash
      --login</command> command. Regardless of whether it's a login shell
      or not, a shell can be interactive (in an
      <command>xterm</command>-type terminal for instance); or
      non-interactive (when executing a script).</para>
    </sidebar>

    <sidebar>
      <title><emphasis>DISCOVERY</emphasis> Other shells, other scripts</title>

      <para>Each command interpreter has a specific syntax and its own
      configuration files. Thus, <command>zsh</command> uses
      <filename>/etc/zshrc</filename> and <filename>/etc/zshenv</filename>;
      <command>csh</command> uses <filename>/etc/csh.cshrc</filename>,
      <filename>/etc/csh.login</filename> and
      <filename>/etc/csh.logout</filename>. The man pages for these
      programs document which files they use.</para>
      <indexterm><primary><command>zsh</command></primary></indexterm>
      <indexterm><primary><command>csh</command></primary></indexterm>
    </sidebar>

    <para>For <command>bash</command>, it is useful to activate
    “automatic completion” in the <filename>/etc/bash.bashrc</filename>
    file (simply uncomment a few lines).</para>

    <sidebar>
      <title><emphasis>BACK TO BASICS</emphasis> Automatic completion</title>
      <indexterm><primary>automatic completion</primary></indexterm>

      <para>Many command interpreters provide a completion feature, which
      allows the shell to automatically complete a partially typed command
      name or argument when the user hits the <keycap>Tab</keycap> key.
      This lets users work more efficiently and be less error-prone.</para>

      <para>This function is very powerful and flexible. It is possible to
      configure its behavior according to each command. Thus, the first
      argument following <command>apt-get</command> will be proposed
      according to the syntax of this command, even if it does not match
      any file (in this case, the possible choices are
      <literal>install</literal>, <literal>remove</literal>,
      <literal>upgrade</literal>, etc.).</para>
    </sidebar>

    <sidebar>
      <title><emphasis>BACK TO BASICS</emphasis> The tilde, a shortcut to HOME</title>
      <indexterm><primary>~</primary></indexterm>
      <indexterm><primary>tilde</primary></indexterm>

      <para>The tilde is often used to indicate the directory to which the
      environment variable, <varname>HOME</varname>, points (being the
      user's home directory, such as <filename>/home/rhertzog/</filename>).
      Command interpreters automatically make the substitution:
      <filename>~/hello.txt</filename> becomes
      <filename>/home/rhertzog/hello.txt</filename>.</para>

      <para>The tilde also allows access to another user's home directory.
      Thus, <filename>~rmas/bonjour.txt</filename> is synonymous with
      <filename>/home/rmas/bonjour.txt</filename>.</para>
    </sidebar>

    <para>In addition to these common scripts, each user can create their
    own <filename>~/.bashrc</filename> and
    <filename>~/.bash_profile</filename> to configure their shell. The most
    common changes are the addition of aliases; these are words that are
    automatically replaced with the execution of a command, which makes it
    faster to invoke that command. For instance, you could create the
    <literal>la</literal> alias for the command <command>ls -la |
    less</command> command; then you only have to type
    <command>la</command> to inspect the contents of a directory in
    detail.</para>

    <sidebar>
      <title><emphasis>BACK TO BASICS</emphasis> Environment variables</title>
      <indexterm><primary>environment</primary><secondary>environment variable</secondary></indexterm>
      <indexterm><primary>variable, environment</primary></indexterm>

      <para>Environment variables allow storage of global settings for the
      shell or various other programs called. They are contextual (each
      process has its own set of environment variables) but inheritable.
      This last characteristic offers the possibility for a login shell to
      declare variables which will be passed down to all programs it
      executes.</para>
    </sidebar>

    <para>Setting default environment variables is an important element of
    shell configuration. Leaving aside the variables specific to a shell,
    it is preferable to place them in the
    <filename>/etc/environment</filename> file, since it is used by the
    various programs likely to initiate a shell session. Variables
    typically defined there include <varname>ORGANIZATION</varname>, which
    usually contains the name of the company or organization, and
    <varname>HTTP_PROXY</varname>, which indicates the existence and
    location of an HTTP proxy.</para>

    <sidebar>
      <title><emphasis>TIP</emphasis> All shells configured identically</title>

      <para>Users often want to configure their login and interactive
      shells in the same way. To do this, they choose to interpret (or
      “source”) the content from <filename>~/.bashrc</filename> in the
      <filename>~/.bash_profile</filename> file. It is possible to do the
      same with files common to all users (by calling
      <filename>/etc/bash.bashrc</filename> from
      <filename>/etc/profile</filename>).</para>
    </sidebar>
  </section>
  <section id="sect.config-printing">
    <title>Printer Configuration</title>
    <indexterm><primary>configuration</primary><secondary>printing</secondary></indexterm>
    <indexterm><primary>printing</primary><secondary>configuration</secondary></indexterm>

    <para>Printer configuration used to cause a great many headaches for
    administrators and users alike. These headaches are now mostly a thing
    of the past, thanks to <emphasis
    role="pkg">cups</emphasis>, the free print server using the IPP
    protocol (Internet Printing Protocol).</para>
    <indexterm><primary>IPP</primary></indexterm>
    <indexterm><primary>Internet Printing Protocol</primary></indexterm>
    <indexterm><primary><command>cups</command></primary></indexterm>

    <para>This program is divided over several Debian packages: <emphasis
    role="pkg">cups</emphasis> is the central print server; <emphasis
    role="pkg">cups-bsd</emphasis> is a compatibility layer allowing use of
    commands from the traditional BSD printing system
    (<command>lpd</command> daemon, <command>lpr</command> and
    <command>lpq</command> commands, etc.); <emphasis
    role="pkg">cups-client</emphasis> contains a group of programs to
    interact with the server (block or unblock a printer, view or delete
    print jobs in progress, etc.); and finally, <emphasis
    role="pkg">cups-driver-gutenprint</emphasis> contains a collection of
    additional printer drivers for <command>cups</command>.</para>
    <indexterm><primary><command>lpr</command></primary></indexterm>
    <indexterm><primary><command>lpd</command></primary></indexterm>
    <indexterm><primary><command>lpq</command></primary></indexterm>

    <sidebar>
      <title><emphasis>COMMUNITY</emphasis> CUPS</title>
      <indexterm><primary>CUPS</primary></indexterm>
      <indexterm><primary>Common Unix Printing System</primary></indexterm>

      <para>CUPS (Common Unix Printing System) is a project (and a trademark)
      managed by Apple, Inc.
      <ulink type="block" url="http://www.cups.org/"/></para>
    </sidebar>

    <para>After installation of these different packages,
    <command>cups</command> is administered easily through a web interface
    accessible at the local address:
    <literal>http://localhost:631/</literal>. There you can add printers
    (including network printers), remove, and administer them. You can also
    administer <command>cups</command> with the
    <command>system-config-printer</command> graphical interface (from the
    Debian package of the same name), which is installed by default if the
    “Desktop environment” task is chosen.</para>
    <indexterm><primary><command>cups</command></primary><secondary>administration</secondary></indexterm>

    <sidebar>
      <title><emphasis>NOTE</emphasis> Obsolescence of <filename>/etc/printcap</filename></title>

      <para><emphasis>cups</emphasis> no longer uses the
      <filename>/etc/printcap</filename> file, which is now obsolete.
      Programs that rely upon this file to get a list of available printers
      will, thus, fail. To avoid this problem, delete this file and make it
      a symbolic link (see sidebar <xref linkend="sidebar.symbolic-link"/>)
      to <filename>/var/run/cups/printcap</filename>, which is maintained
      by <emphasis>cups</emphasis> to ensure compatibility.</para>
      <indexterm><primary><filename>printcap</filename></primary></indexterm>
    </sidebar>
  </section>
  <section id="sect.config-bootloader">
    <title>Configuring the Bootloader</title>
    <indexterm><primary>loader</primary><secondary>bootloader</secondary></indexterm>
    <indexterm><primary>bootloader</primary></indexterm>

    <para>It is probably already functional, but it is always good to know
    how to configure and install the bootloader in case it disappears from
    the Master Boot Record. This can occur after installation of another
    operating system, such as Windows. The following information can also
    help you to modify the bootloader configuration if needed.</para>

    <sidebar>
      <title><emphasis>BACK TO BASICS</emphasis> Master boot record</title>
      <indexterm><primary>MBR</primary></indexterm>
      <indexterm><primary>Master Boot Record</primary></indexterm>

      <para>The Master Boot Record (MBR) occupies the first 512 bytes of
      the first hard disk, and is the first thing loaded by the BIOS to
      hand over control to a program capable of booting the desired
      operating system. In general, a bootloader gets installed in the MBR,
      removing its previous content.</para>
    </sidebar>
    <section id="sect.identify-disks">
      <title>Identifying the Disks</title>

      <sidebar>
        <title><emphasis>CULTURE</emphasis> <emphasis>udev</emphasis> and <filename>/dev/</filename></title>

	<para>The <filename>/dev/</filename> directory traditionally houses
	so-called “special” files, intended to represent system
	peripherals (see sidebar <xref
	linkend="sidebar.special-files"/>). Once upon a time, it used to contain
	all special files that could potentially be used. This approach had a number
	of drawbacks among which the fact that it restricted the number of devices
	that one could use (due to the hardcoded list of names), and that it was
	impossible to know which special files were actually useful.</para>

	<para>Nowadays, the management of special files is entirely
	dynamic and matches better the nature of hot-swappable computer
	devices. The kernel cooperates with <emphasis>udev</emphasis> to
	create and delete them as needed when the corresponding devices
	appear and disappear.  For this reason, <filename>/dev/</filename>
	doesn't need to be persistent and is thus a RAM-based filesystem
	that starts empty and contains only the relevant entries.</para>

	<para>The kernel communicates lots of information about any newly added
	device and hands out a pair of major/minor numbers to identify it. With
	this <command>udevd</command> can create the special file under the
	name and with the permissions that it wants. It can also create aliases
	and do additional actions (initialization or registration tasks for
	example). <command>udevd</command>'s behavior is driven by a
	large set of (customizable) rules.</para>

	<para>With dynamically assigned names, you can thus keep the same name
	for a given device, regardless of the connector used or the connection order, which is
	especially useful when you use various USB peripherals. The
	first partition on the first hard drive can then be called
	<filename>/dev/sda1</filename> for backwards compatibility, or
	<filename>/dev/root-partition</filename> if you prefer, or even
	both at the same time since <command>udevd</command> can be
	configured to automatically create a symbolic link.</para>

	<para>Previously, some kernel modules did automatically load
	when you tried to access the corresponding device file; henceforth,
	the peripheral's special file no longer exists prior to loading the
	module, which is no big deal, since most modules are loaded on boot
	thanks to automatic hardware detection. But for undetectable
	peripherals (such as older disk drives or PS/2 mice), this doesn't
	work. Consider adding the modules, <literal>floppy</literal>,
	<literal>psmouse</literal> and <literal>mousedev</literal> to
	<filename>/etc/modules</filename> in order to force loading them on
	boot.</para>
      </sidebar>

      <indexterm><primary>hard drive, names</primary></indexterm>
      <indexterm><primary>names</primary><secondary>of hard drives</secondary></indexterm>

      <para>Configuration of the bootloader must identify the different
      hard drives and their partitions. Linux uses “block” special files
      stored in the <filename>/dev/</filename> directory,
      for this purpose. Historically, <filename>/dev/hda</filename> was the
      master disk on the first IDE controller, and
      <filename>/dev/hdb</filename> its first slave,
      <filename>/dev/hdc</filename> and <filename>/dev/hdd</filename>
      being, respectively, the master and slave disks on the second IDE
      controller, and so on down for any others.
      <filename>/dev/sda</filename> corresponded to the first SCSI drive,
      <filename>/dev/sdb</filename> being the second, etc. Since Debian
      <emphasis role="distribution">Squeeze</emphasis>, this naming scheme
      has been unified by the Linux kernel, and
      all hard drives (IDE/PATA, SATA, SCSI, USB, IEEE 1394) are now
      represented by <filename>/dev/sd*</filename>.</para>

      <para>Each partition is represented by its number on the disk on
      which it resides: for instance, <filename>/dev/sda1</filename> is the
      first partition on the first disk, and <filename>/dev/sdb3</filename>
      is the third partition on the second disk.</para>

      <para>The PC architecture (or “i386”) is limited to four
      “primary” partitions per disk. To go beyond this limitation, one
      of them must be created as an “extended” partition, and it can
      then contain additional “secondary” partitions. These secondary
      partitions must be numbered from 5. Thus the first secondary
      partition could be <filename>/dev/sda5</filename>, followed by
      <filename>/dev/sda6</filename>, etc.</para>
      <indexterm><primary>partition</primary><secondary>primary</secondary></indexterm>
      <indexterm><primary>partition</primary><secondary>extended</secondary></indexterm>
      <indexterm><primary>partition</primary><secondary>secondary</secondary></indexterm>

      <para>It is not always easy to remember what disk is connected to
      which SATA controller, or in third position in the SCSI chain,
      especially since the naming of hotplugged hard drives (which includes
      among others most SATA disks and external disks) can change from one
      boot to another. Fortunately, <command>udev</command> creates, in
      addition to <filename>/dev/sd*</filename>, symbolic links with a
      fixed name, which you could then use if you wished to identify a hard
      drive in a non-ambiguous manner. These symbolic links are stored in
      <filename>/dev/disk/by-id</filename>. On a machine with two physical
      disks, for example, one could find the following:</para>

      <screen>mirexpress:/dev/disk/by-id# <computeroutput/><userinput>ls -l</userinput><computeroutput>
total 0
lrwxrwxrwx 1 root root  9 23 jul. 08:58 ata-STM3500418AS_9VM3L3KP -&gt; ../../sda
lrwxrwxrwx 1 root root 10 23 jul. 08:58 ata-STM3500418AS_9VM3L3KP-part1 -&gt; ../../sda1
lrwxrwxrwx 1 root root 10 23 jul. 08:58 ata-STM3500418AS_9VM3L3KP-part2 -&gt; ../../sda2
[...]
lrwxrwxrwx 1 root root  9 23 jul. 08:58 ata-WDC_WD5001AALS-00L3B2_WD-WCAT00241697 -&gt; ../../sdb
lrwxrwxrwx 1 root root 10 23 jul. 08:58 ata-WDC_WD5001AALS-00L3B2_WD-WCAT00241697-part1 -&gt; ../../sdb1
lrwxrwxrwx 1 root root 10 23 jul. 08:58 ata-WDC_WD5001AALS-00L3B2_WD-WCAT00241697-part2 -&gt; ../../sdb2
[...]
lrwxrwxrwx 1 root root  9 23 jul. 08:58 scsi-SATA_STM3500418AS_9VM3L3KP -&gt; ../../sda
lrwxrwxrwx 1 root root 10 23 jul. 08:58 scsi-SATA_STM3500418AS_9VM3L3KP-part1 -&gt; ../../sda1
lrwxrwxrwx 1 root root 10 23 jul. 08:58 scsi-SATA_STM3500418AS_9VM3L3KP-part2 -&gt; ../../sda2
[...]
lrwxrwxrwx 1 root root  9 23 jul. 08:58 scsi-SATA_WDC_WD5001AALS-_WD-WCAT00241697 -&gt; ../../sdb
lrwxrwxrwx 1 root root 10 23 jul. 08:58 scsi-SATA_WDC_WD5001AALS-_WD-WCAT00241697-part1 -&gt; ../../sdb1
lrwxrwxrwx 1 root root 10 23 jul. 08:58 scsi-SATA_WDC_WD5001AALS-_WD-WCAT00241697-part2 -&gt; ../../sdb2
[...]
lrwxrwxrwx 1 root root  9 23 jul. 16:48 usb-LaCie_iamaKey_3ed00e26ccc11a-0:0 -&gt; ../../sdc
lrwxrwxrwx 1 root root 10 23 jul. 16:48 usb-LaCie_iamaKey_3ed00e26ccc11a-0:0-part1 -&gt; ../../sdc1
lrwxrwxrwx 1 root root 10 23 jul. 16:48 usb-LaCie_iamaKey_3ed00e26ccc11a-0:0-part2 -&gt; ../../sdc2
[...]
lrwxrwxrwx 1 root root  9 23 jul. 08:58 wwn-0x5000c50015c4842f -&gt; ../../sda
lrwxrwxrwx 1 root root 10 23 jul. 08:58 wwn-0x5000c50015c4842f-part1 -&gt; ../../sda1
[...]
mirexpress:/dev/disk/by-id# </computeroutput>
</screen>

      <para>Note that some disks are listed several times (because they
      behave simultaneously as ATA disks and SCSI disks), but the relevant
      information is mainly in the model and serial numbers of the disks,
      from which you can find the peripheral file.</para>

      <para>The example configuration files given in the following sections
      are based on the same setup: a single SATA disk, where the
      first partition is an old Windows installation and the second
      contains Debian GNU/Linux.</para>
    </section>
    <section id="sect.config-lilo">
      <title>Configuring LILO</title>
      <indexterm><primary>LILO</primary></indexterm>
      <indexterm><primary>Linux Loader</primary></indexterm>

      <para><emphasis>LILO</emphasis> (LInux LOader) is the oldest
      bootloader — solid but rustic. It writes the physical address of
      the kernel to boot on the MBR, which is why each update to LILO (or
      its configuration file) must be followed by the command
      <command>lilo</command>. Forgetting to do so will render a system
      unable to boot if the old kernel was removed or replaced as the new
      one will not be in the same location on the disk.</para>

      <para>LILO's configuration file is
      <filename>/etc/lilo.conf</filename>; a simple file for standard
      configuration is illustrated in the example below.</para>

      <example id="example.lilo.conf">
        <title>LILO configuration file</title>

        <programlisting>
# The disk on which LILO should be installed.
# By indicating the disk and not a partition.
# you order LILO to be installed on the MBR.
boot=/dev/sda
# the partition that contains Debian
root=/dev/sda2
# the item to be loaded by default
default=Linux

# the most recent kernel image
image=/vmlinuz
  label=Linux
  initrd=/initrd.img
  read-only

# Old kernel (if the newly installed kernel doesn't boot)
image=/vmlinuz.old
  label=LinuxOLD
  initrd=/initrd.img.old
  read-only
  optional

# only for Linux/Windows dual boot
other=/dev/sda1
  label=Windows
</programlisting>
      </example>
    </section>
    <section id="sect.config-grub">
      <title>GRUB 2 Configuration</title>
      <indexterm><primary>GRUB</primary></indexterm>
      <indexterm><primary>GRUB 2</primary></indexterm>

      <para><emphasis>GRUB</emphasis> (GRand Unified Bootloader) is more
      recent. It is not necessary to invoke it after each update of the
      kernel; <emphasis>GRUB</emphasis> knows how to read the filesystems
      and find the position of the kernel on the disk by itself. To install
      it on the MBR of the first disk, simply type <command>grub-install
      /dev/sda</command>.
      <indexterm><primary><command>grub-install</command></primary></indexterm></para>

      <sidebar>
        <title><emphasis>NOTE</emphasis> Disk names for GRUB</title>

	<para>GRUB can only identify hard drives based on information
	provided by the BIOS. <literal>(hd0)</literal> corresponds to the
	first disk thus detected, <literal>(hd1)</literal> the second, etc.
	In most cases, this order corresponds exactly to the usual order of
	disks under Linux, but problems can occur when you associate SCSI
	and IDE disks. GRUB stores correspondences that it detects in the
	file <filename>/boot/grub/device.map</filename>. If you find errors
	there (because you know that your BIOS detects drives in a
	different order), correct them manually and run
	<command>grub-install</command> again.</para>

	<para>Partitions also have a specific name in GRUB. When you use
	“classical” partitions in MS-DOS format, the first partition on
	the first disk is labeled, <literal>(hd0,msdos1)</literal>, the
	second <literal>(hd0,msdos2)</literal>, etc.</para>
      </sidebar>

      <para>GRUB 2 configuration is stored in
      <filename>/boot/grub/grub.cfg</filename>, but this file (in Debian)
      is generated from others. Be careful not to modify it by hand, since
      such local modifications will be lost the next time
      <command>update-grub</command> is run (which may occur upon update of
      various packages). The most common modifications of the
      <filename>/boot/grub/grub.cfg</filename> file (to add command line
      parameters to the kernel or change the duration that the menu is
      displayed, for example) are made through the variables in
      <filename>/etc/default/grub</filename>. To add entries to the menu,
      you can either create a <filename>/boot/grub/custom.cfg</filename>
      file or modify the <filename>/etc/grub.d/50_custom</filename> file.
      For more complex configurations, you can modify other files in
      <filename>/etc/grub.d</filename>, or add to them; these scripts
      should return configuration snippets, possibly by making use of
      external programs. These scripts are the ones that will update the
      list of kernels to boot: <filename>10_linux</filename> takes into
      consideration the installed Linux kernels;
      <filename>20_linux_xen</filename> takes into account Xen virtual systems,
      and <filename>30_os-prober</filename> lists other operating systems
      (Windows, Mac OSX, Hurd).</para>
    </section>
    <section id="sect.config-yaboot">
      <title>For Macintosh Computers (PowerPC): Configuring Yaboot</title>
      <indexterm><primary><command>yaboot</command></primary></indexterm>

      <para>Yaboot is the bootloader used by old Macintosh computers using
      PowerPC processors. They do not boot like PCs, but rely on a
      “bootstrap” partition, from which the BIOS (or OpenFirmware)
      executes the loader, and on which the <command>ybin</command> program
      installs <command>yaboot</command> and its configuration file. You
      will only need to run this command again if the
      <filename>/etc/yaboot.conf</filename> is modified (it is duplicated
      on the bootstrap partition, and <command>yaboot</command> knows how
      to find the position of the kernels on the disks).</para>

      <para>Before executing <command>ybin</command>, you must first have a
      valid <filename>/etc/yaboot.conf</filename>. The following is an
      example of a minimal configuration.
      <indexterm><primary><command>ybin</command></primary></indexterm></para>

      <example id="example.yaboot.conf">
        <title>Yaboot configuration file</title>

        <programlisting>
# bootstrap partition
boot=/dev/sda2
# the disk
device=hd:
# the Linux partition
partition=3
root=/dev/sda3
# boot after 3 seconds of inactivity
# (timeout is in tenths of seconds)
timeout=30

install=/usr/lib/yaboot/yaboot
magicboot=/usr/lib/yaboot/ofboot
enablecdboot

# last kernel installed
image=/vmlinux
        label=linux
        initrd=/initrd.img
        read-only

# old kernel
image=/vmlinux.old
        label=old
        initrd=/initrd.img.old
        read-only

# only for Linux/Mac OSX dual-boot
macosx=/dev/sda5

# bsd=/dev/sdaX and macos=/dev/sdaX
# are also possible
</programlisting>
      </example>
    </section>
  </section>
  <section id="sect.config-misc">
    <title>Other Configurations: Time Synchronization, Logs, Sharing Access…</title>

    <para>The many elements listed in this section are good to know for
    anyone who wants to master all aspects of configuration of the
    GNU/Linux system. They are, however, treated briefly and frequently
    refer to the documentation.</para>

    <section id="sect.timezone">
      <title>Timezone</title>
      <indexterm><primary>timezone</primary></indexterm>

      <sidebar id="sidebar.symbolic-link">
        <title><emphasis>BACK TO BASICS</emphasis> Symbolic links</title>
        <indexterm><primary>link</primary><secondary>symbolic</secondary></indexterm>
        <indexterm><primary>symbolic link</primary></indexterm>
        <indexterm><primary><command>ln</command></primary></indexterm>

	<para>A symbolic link is a pointer to another file. When you access
	it, the file to which it points is opened. Removal of the link will
	not cause deletion of the file to which it points. Likewise, it
	does not have its own set of permissions, but rather retains the
	permissions of its target. Finally, it can point to any type of
	file: directories, special files (sockets, named pipes, device
	files, etc.), even other symbolic links.</para>

	<para>The <command>ln -s <replaceable>target</replaceable>
	<replaceable>link-name</replaceable></command> command creates a
	symbolic link, named <replaceable>link-name</replaceable>, pointing
	to <replaceable>target</replaceable>.</para>

	<para>If the target does not exist, then the link is “broken”
	and accessing it will result in an error indicating that the target
	file does not exist. If the link points to another link, you will
	have a “chain” of links that turns into a “cycle” if one of
	the targets points to one of its predecessors. In this case,
	accessing one of the links in the cycle will result in a specific
	error (“too many levels of symbolic links”); this means the
	kernel gave up after several rounds of the cycle.</para>
      </sidebar>

      <para>The timezone, configured during initial installation, is a
      configuration item for the <emphasis role="pkg">tzdata</emphasis>
      package. To modify it, use the <command>dpkg-reconfigure
      tzdata</command> command, which allows you to choose the timezone to
      be used in an interactive manner. Its configuration is stored in the
      <filename>/etc/timezone</filename> file. Additionally, the
      corresponding file in the <filename>/usr/share/zoneinfo</filename>
      directory is copied in <filename>/etc/localtime</filename>; this file
      contains the rules governing the dates where daylight saving time is
      active, for countries that use it.</para>
      <indexterm><primary><filename>timezone</filename></primary></indexterm>
      <indexterm><primary><filename>/etc/timezone</filename></primary></indexterm>
      <indexterm><primary><filename>zoneinfo</filename></primary></indexterm>
      <indexterm><primary><filename>/usr/share/zoneinfo/</filename></primary></indexterm>
      <indexterm><primary>DST</primary></indexterm>
      <indexterm><primary>daylight saving time</primary></indexterm>

      <para>When you need to temporarily change the timezone, use the
      <varname>TZ</varname> environment variable, which takes priority over
      the configured system default:</para>
      <indexterm><primary><varname>TZ</varname></primary></indexterm>

      <screen id="screen.tz">
<computeroutput>$ </computeroutput><userinput>date</userinput>
<computeroutput>Wed Mar 28 15:51:19 CEST 2012</computeroutput>
<computeroutput>$ </computeroutput><userinput>TZ="Pacific/Honolulu" date</userinput>
<computeroutput>Wed Mar 28 03:51:21 HST 2012</computeroutput></screen>

      <sidebar>
        <title><emphasis>NOTE</emphasis> System clock, hardware clock</title>

	<para>There are two time sources in a computer. A computer's
	motherboard has a hardware clock, called the “CMOS clock”. This
	clock is not very precise, and provides rather slow access times.
	The operating system kernel has its own, the software clock, which
	it keeps up to date with its own means (possibly with the help of
	time servers, see the “Time Synchronization” section). This
	system clock is generally more accurate, especially since it
	doesn't need access to hardware variables. However, since it only
	exists in live memory, it is zeroed out every time the machine is
	booted, contrary to the CMOS clock, which has a battery and
	therefore “survives” rebooting or halting of the machine. The
	system clock is, thus, set from the CMOS clock during boot, and the
	CMOS clock is updated on shutdown (to take into account possible
	changes or corrections if it has been improperly adjusted).</para>

	<para>In practice, there is a problem, since the CMOS clock is
	nothing more than a counter and contains no information regarding
	the time zone. There is a choice to make regarding its
	interpretation: either the system considers it runs in universal
	time (UTC, formerly GMT), or in local time. This choice could be a
	simple shift, but things are actually more complicated: as a result
	of daylight saving time, this offset is not constant. The result is
	that the system has no way to determine whether the offset is
	correct, especially around periods of time change. Since it is
	always possible to reconstruct local time from universal time and
	the timezone information, we strongly recommend using the CMOS
	clock in universal time.</para>

	<para>Unfortunately, Windows systems in their default configuration
	ignore this recommendation; they keep the CMOS clock on local time,
	applying time changes when booting the computer by trying to guess
	during time changes if the change has already been applied or not.
	This works relatively well, as long as the system has only Windows
	running on it. But when a computer has several systems (whether it
	be a “dual-boot” configuration or running other systems via
	virtual machine), chaos ensues, with no means to determine if the
	time is correct. If you absolutely must retain Windows on a
	computer, you should either configure it to keep the CMOS clock as
	UTC (setting the registry key
	<literal>HKLM\SYSTEM\CurrentControlSet\Control\TimeZoneInformation\RealTimeIsUniversal</literal>
	to “1” as a DWORD), or use <command>hwclock --localtime --set</command>
	on the Debian system to set the hardware clock and mark it as tracking
	the local time (and make sure to manually check your clock in spring and
	autumn).</para>
      </sidebar>
    </section>
    <section id="sect.time-synchronization">
      <title>Time Synchronization</title>
      <indexterm><primary>time synchronization</primary></indexterm>
      <indexterm><primary>clock</primary><secondary>synchronization</secondary></indexterm>

      <para>Time synchronization, which may seem superfluous on a computer,
      is very important on a network. Since users do not have permissions
      allowing them to modify the date and time, it is important for this
      information to be precise to prevent confusion. Furthermore, having
      all of the computers on a network synchronized allows better
      cross-referencing of information from logs on different machines.
      Thus, in the event of an attack, it is easier to reconstruct the
      chronological sequence of actions on the various machines involved in
      the compromise. Data collected on several machines for statistical
      purposes won't make a great deal of sense if they are not
      synchronized.</para>

      <sidebar>
        <title><emphasis>BACK TO BASICS</emphasis> NTP</title>
        <indexterm><primary>NTP</primary></indexterm>
        <indexterm><primary>Network</primary><secondary>Time Protocol</secondary></indexterm>

	<para>NTP (Network Time Protocol) allows a machine to synchronize
	with others fairly accurately, taking into consideration the delays
	induced by the transfer of information over the network and other
	possible offsets.</para>

	<para>While there are numerous NTP servers on the Internet, the
	more popular ones may be overloaded. This is why we recommend using
	the <emphasis>pool.ntp.org</emphasis> NTP server, which is, in
	reality, a group of machines that have agreed to serve as public
	NTP servers. You could even limit use to a sub-group specific to a
	country, with, for example, <emphasis>us.pool.ntp.org</emphasis>
	for the United States, or <emphasis>ca.pool.ntp.org</emphasis> for
	Canada, etc.</para>

	<para>However, if you manage a large network, it is recommended
	that you install your own NTP server, which will synchronize with
	the public servers. In this case, all the other machines on your
	network can use your internal NTP server instead of increasing the
	load on the public servers. You will also increase homogeneity with
	your clocks, since all the machines will be synchronized on the
	same source, and this source is very close in terms of network
	transfer times.</para>
      </sidebar>
      <section id="sect.ntp-on-workstations">
        <title>For Workstations</title>

	<para>Since work stations are regularly rebooted (even if only to
	save energy), synchronizing them by NTP at boot is enough. To do
	so, simply install the <emphasis role="pkg">ntpdate</emphasis>
	package. You can change the NTP server used if needed by modifying
	the <filename>/etc/default/ntpdate</filename> file.</para>
        <indexterm><primary><filename>ntpdate</filename></primary></indexterm>
        <indexterm><primary><filename>/etc/default/ntpdate</filename></primary></indexterm>
      </section>
      <section id="sect.ntp-on-servers">
        <title>For Servers</title>

	<para>Servers are only rarely rebooted, and it is very important
	for their system time to be correct. To permanently maintain
	correct time, you would install a local NTP server, a service
	offered in the <emphasis role="pkg">ntp</emphasis> package. In its
	default configuration, the server will synchronize with
	<emphasis>pool.ntp.org</emphasis> and provide time in response to
	requests coming from the local network. You can configure it by
	editing the <filename>/etc/ntp.conf</filename> file, the most
	significant alteration being the NTP server to which it refers. If
	the network has a lot of servers, it may be interesting to have one
	local time server which synchronizes with the public servers and is
	used as a time source by the other servers of the network.</para>
        <indexterm><primary><emphasis role="pkg">ntp</emphasis></primary></indexterm>
        <indexterm><primary>server</primary><secondary>NTP</secondary></indexterm>
        <indexterm><primary>NTP</primary><secondary>server</secondary></indexterm>

        <sidebar>
          <title><emphasis>GOING FURTHER</emphasis> GPS modules and other time sources</title>
          <indexterm><primary>GPS</primary></indexterm>
          <indexterm><primary>DCF-77</primary></indexterm>

	  <para>If time synchronization is particularly crucial to your
	  network, it is possible to equip a server with a GPS module
	  (which will use the time from GPS satellites) or a DCF-77 module
	  (which will sync time with the atomic clock near Frankfurt,
	  Germany). In this case, the configuration of the NTP server is a
	  little more complicated, and prior consultation of the
	  documentation is an absolute necessity.</para>
        </sidebar>
      </section>
    </section>
    <section id="sect.rotation-logs">
      <title>Rotating Log Files</title>
      <indexterm><primary>file</primary><secondary>logs, rotation</secondary></indexterm>
      <indexterm><primary>logs</primary><secondary>files, rotation</secondary></indexterm>
      <indexterm><primary>rotation of log files</primary></indexterm>
      <indexterm><primary><command>logrotate</command></primary></indexterm>

      <para>Log files can grow, fast, and it is necessary to archive them.
      The most common scheme is a rotating archive: the log file is
      regularly archived, and only the latest <replaceable>X</replaceable>
      archives are retained. <command>logrotate</command>, the program
      responsible for these rotations, follows directives given in the
      <filename>/etc/logrotate.conf</filename> file and all of the files in
      the <filename>/etc/logrotate.d/</filename> directory. The
      administrator may modify these files, if they wish to adapt the log
      rotation policy defined by Debian. The
      <citerefentry><refentrytitle>logrotate</refentrytitle>
      <manvolnum>1</manvolnum></citerefentry> man page describes all of the
      options available in these configuration files. You may want to
      increase the number of files retained in log rotation, or move the
      log files to a specific directory dedicated to archiving them rather
      than delete them. You could also send them by e-mail to archive them
      elsewhere.</para>

      <para>The <command>logrotate</command> program is executed daily by
      the <command>cron</command> scheduling program (described in <xref
      linkend="sect.task-scheduling-cron-atd"/>).</para>
    </section>
    <section id="sect.sharing-admin-rights">
      <title>Sharing Administrator Rights</title>
      <indexterm><primary>account</primary><secondary>administrator account</secondary></indexterm>
      <indexterm><primary>root</primary></indexterm>
      <indexterm><primary><command>sudo</command></primary></indexterm>

      <para>Frequently, several administrators work on the same network.
      Sharing the root passwords is not very elegant, and opens the
      door for abuse due to the anonymity such sharing creates. The
      solution to this problem is the <command>sudo</command> program,
      which allows certain users to execute certain commands with special
      rights. In the most common use case, <command>sudo</command> allows a
      trusted user to execute any command as root. To do so, the user
      simply executes <command>sudo
      <replaceable>command</replaceable></command> and authenticates using
      their personal password.</para>

      <para>When installed, the <emphasis role="pkg">sudo</emphasis>
      package gives full root rights to members of the
      <literal>sudo</literal> Unix group. To delegate other rights, the
      administrator must use the <command>visudo</command> command, which
      allows them to modify the <filename>/etc/sudoers</filename>
      configuration file (here again, this will invoke the
      <command>vi</command> editor, or any other editor indicated in the
      <varname>EDITOR</varname> environment variable). Adding a line with
      <literal><replaceable>username</replaceable> ALL=(ALL) ALL</literal>
      allows the user in question to execute any command as root.</para>
      <indexterm><primary><command>visudo</command></primary></indexterm>
      <indexterm><primary><filename>sudoers</filename></primary></indexterm>
      <indexterm><primary><filename>/etc/sudoers</filename></primary></indexterm>

      <para>More sophisticated configurations allow authorization of only
      specific commands to specific users. All the details of the various
      possibilities are given in the
      <citerefentry><refentrytitle>sudoers</refentrytitle>
      <manvolnum>5</manvolnum></citerefentry> man page.</para>
    </section>
    <section id="sect.fstab-mount-points">
      <title>List of Mount Points</title>
      <indexterm><primary>point, mount</primary></indexterm>
      <indexterm><primary>mount point</primary></indexterm>

      <sidebar>
        <title><emphasis>BACK TO BASICS</emphasis> Mounting and unmounting</title>

	<para>In a Unix-like system such as Debian, files are organized in
	a single tree-like hierarchy of directories. The
	<filename>/</filename> directory is called the “root
	directory”; all additional directories are sub-directories within
	this root. “Mounting” is the action of including the content of
	a peripheral device (often a hard drive) into the system's general
	file tree. As a consequence, if you use a separate hard drive to
	store users' personal data, this disk will have to be “mounted”
	in the <filename>/home/</filename> directory. The root filesystem
	is always mounted at boot by the kernel; other devices are often
	mounted later during the startup sequence or manually with the
	<command>mount</command> command.</para>
        <indexterm><primary><command>mount</command></primary></indexterm>

	<para>Some removable devices are automatically mounted when
	connected, especially when using the GNOME, KDE or other graphical
	desktop environments. Others have to be mounted manually by the
	user. Likewise, they must be unmounted (removed from the file
	tree). Normal users do not usually have permission to execute the
	<command>mount</command> and <command>umount</command> commands.
	The administrator can, however, authorize these operations
	(independently for each mount point) by including the
	<literal>user</literal> option in the
	<filename>/etc/fstab</filename> file.</para>

	<para>The <command>mount</command> command can be used without
	arguments (it then lists all mounted filesystems). The following
	parameters are required to mount or unmount a device. For the
	complete list, please refer to the corresponding man pages,
	<citerefentry><refentrytitle>mount</refentrytitle>
	<manvolnum>8</manvolnum></citerefentry> and
	<citerefentry><refentrytitle>umount</refentrytitle>
	<manvolnum>8</manvolnum></citerefentry>. For simple cases, the
	syntax is simple too: for example, to mount the
	<filename>/dev/sdc1</filename> partition, which has an ext3
	filesystem, into the <filename>/mnt/tmp/</filename> directory, you
	would simply run <command>mount -t ext3 /dev/sdc1
	/mnt/tmp/</command>.</para>
      </sidebar>

      <para>The <filename>/etc/fstab</filename> file gives a list of all
      possible mounts that happen either automatically on boot or manually
      for removable storage devices. Each mount point is described by a
      line with several space-separated fields:
      <indexterm><primary><filename>fstab</filename></primary></indexterm>
      <indexterm><primary><filename>/etc/fstab</filename></primary></indexterm></para>
      <itemizedlist>
        <listitem>
	  <para>device to mount: this can be a local partition (hard drive,
	  CD-ROM) or a remote filesystem (such as NFS).</para>

	  <para>This field is frequently replaced with the unique ID of the
	  filesystem (which you can determine with <command>blkid
	  <userinput>device</userinput></command>) prefixed with
	  <literal>UUID=</literal>. This guards against a change in the
	  name of the device in the event of addition or removal of disks,
	  or if disks are detected in a different order.</para>
        </listitem>
        <listitem>
	  <para>mount point: this is the location on the local filesystem
	  where the device, remote system, or partition will be
	  mounted.</para>
        </listitem>
        <listitem>
	  <para>type: this field defines the filesystem used on the mounted
	  device. <literal>ext4</literal>, <literal>ext3</literal>,
	  <literal>vfat</literal>, <literal>ntfs</literal>,
	  <literal>btrfs</literal>, <literal>xfs</literal> are a few
	  examples.</para>

          <sidebar>
            <title><emphasis>BACK TO BASICS</emphasis> NFS, a network filesystem</title>

	    <para>NFS is a network filesystem; under Linux, it allows
	    transparent access to remote files by including them in the
	    local filesystem.</para>
          </sidebar>

	  <para>A complete list of known filesystems is available in the
	  <citerefentry><refentrytitle>mount</refentrytitle>
	  <manvolnum>8</manvolnum></citerefentry> man page. The
	  <literal>swap</literal> special value is for swap partitions; the
	  <literal>auto</literal> special value tells the
	  <command>mount</command> program to automatically detect the
	  filesystem (which is especially useful for disk readers and USB
	  keys, since each one might have a different filesystem);</para>
        </listitem>
        <listitem>
	  <para>options: there are many of them, depending on the
	  filesystem, and they are documented in the
	  <command>mount</command> man page. The most common are</para>
          <itemizedlist>
            <listitem>
	      <para><literal>rw</literal> or <literal>ro</literal>,
	      meaning, respectively, that the device will be mounted with
	      read/write or read-only permissions.</para>
            </listitem>
            <listitem>
	      <para><literal>noauto</literal> deactivates automatic
	      mounting on boot.</para>
            </listitem>
            <listitem>
	      <para><literal>user</literal> authorizes all users to mount
	      this filesystem (an operation which would otherwise be
	      restricted to the root user).</para>
            </listitem>
            <listitem>
	      <para><literal>defaults</literal> means the group of default
	      options: <literal>rw</literal>, <literal>suid</literal>,
	      <literal>dev</literal>, <literal>exec</literal>,
	      <literal>auto</literal>, <literal>nouser</literal> and
	      <literal>async</literal>, each of which can be individually
	      disabled after <literal>defaults</literal> by adding
	      <literal>nosuid</literal>, <literal>nodev</literal> and so on
	      to block <literal>suid</literal>, <literal>dev</literal> and
	      so on. Adding the <literal>user</literal> option reactivates
	      it, since <literal>defaults</literal> includes
	      <literal>nouser</literal>.</para>
            </listitem>
          </itemizedlist>
        </listitem>
        <listitem>
	  <para>backup: this field is almost always set to
	  <literal>0</literal>. When it is <literal>1</literal>, it tells
	  the <command>dump</command> tool that the partition contains data
	  that is to be backed up.</para>
        </listitem>
        <listitem>
	  <para>check order: this last field indicates whether the
	  integrity of the filesystem should be checked on boot, and in
	  which order this check should be executed. If it is
	  <literal>0</literal>, no check is conducted. The root filesystem
	  should have the value <literal>1</literal>, while other permanent
	  filesystems get the value <literal>2</literal>.</para>
        </listitem>
      </itemizedlist>

      <example id="example.fstab">
        <title>Example <filename>/etc/fstab</filename> file:</title>

        <programlisting>
# /etc/fstab: static file system information.
#
# &lt;file system&gt; &lt;mount point&gt;   &lt;type&gt;  &lt;options&gt;       &lt;dump&gt;  &lt;pass&gt;
proc            /proc           proc    defaults        0       0
# / was on /dev/sda1 during installation
UUID=c964222e-6af1-4985-be04-19d7c764d0a7 / ext3 errors=remount-ro 0 1
# swap was on /dev/sda5 during installation
UUID=ee880013-0f63-4251-b5c6-b771f53bd90e none swap sw  0       0
/dev/scd0       /media/cdrom0   udf,iso9660 user,noauto 0       0
/dev/fd0        /media/floppy   auto    rw,user,noauto  0       0
arrakis:/shared /shared         nfs     defaults        0       0
</programlisting>
      </example>

      <para>The last entry in this example corresponds to a network
      filesystem (NFS): the <filename>/shared/</filename> directory on the
      <emphasis>arrakis</emphasis> server is mounted at
      <filename>/shared/</filename> on the local machine. The format of the
      <filename>/etc/fstab</filename> file is documented on the
      <citerefentry><refentrytitle>fstab</refentrytitle><manvolnum>5</manvolnum></citerefentry>
      man page.</para>

      <sidebar>
        <title><emphasis>GOING FURTHER</emphasis> Auto-mounting</title>

	<para>The <emphasis>am-utils</emphasis> package provides the
	<command>amd</command> auto-mounting utility, able to mount
	removable media on demand when a user attempts to access their
	usual mount point. It will unmount these devices when no process is
	accessing them any longer.</para>
        <indexterm><primary><emphasis>am-utils</emphasis></primary></indexterm>
        <indexterm><primary><command>amd</command></primary></indexterm>
        <indexterm><primary><command>automount</command></primary></indexterm>
        <indexterm><primary><emphasis>autofs</emphasis></primary></indexterm>
        <indexterm><primary>automounter</primary></indexterm>

	<para>Other auto-mounting utilities exist, such as
	<command>automount</command> in the <emphasis>autofs</emphasis>
	package.</para>

	<para>Note also that GNOME, KDE, and other graphical desktop
	environments work together with <emphasis>udisks</emphasis>,
	and can automatically mount removable media when they are connected.</para>
      </sidebar>
    </section>
    <section id="sect.locate-updatedb">
      <title><command>locate</command> and <command>updatedb</command></title>
      <indexterm><primary><command>locate</command></primary></indexterm>
      <indexterm><primary><command>updatedb</command></primary></indexterm>
      <indexterm><primary><command>mlocate</command></primary></indexterm>

      <para>The <command>locate</command> command can find the location of
      a file when you only know part of the name. It sends a result almost
      instantaneously, since it consults a database that stores the
      location of all the files on the system; this database is updated
      daily by the <command>updatedb</command> command. There are multiple
      implementations of the <command>locate</command> command and Debian
      picked <emphasis role="pkg">mlocate</emphasis> for its standard
      system.</para>

      <para><command>mlocate</command> is smart enough to only return
      files which are accessible to the user running the command even
      though it uses a database that knows about all files on the system
      (since its <command>updatedb</command> implementation runs with
      root rights). For extra safety, the administrator can use
      <varname>PRUNEDPATHS</varname> in
      <filename>/etc/updatedb.conf</filename> to exclude some directories
      from being indexed.</para>
    </section>
  </section>
  <section id="sect.kernel-compilation">
    <title>Compiling a Kernel</title>
    <indexterm><primary>compilation</primary><secondary>of a kernel</secondary></indexterm>
    <indexterm><primary>kernel</primary><secondary>compilation</secondary></indexterm>

    <para>The kernels provided by Debian include the largest possible
    number of features, as well as the maximum of drivers, in order to
    cover the broadest spectrum of existing hardware configurations. This
    is why some users prefer to recompile the kernel in order to only
    include what they specifically need. There are two reasons for this
    choice. First, it may be to optimize memory consumption, since the
    kernel code, even if it is never used, occupies memory for nothing (and
    never “goes down” on the swap space, since it is actual RAM that it
    uses), which can decrease overall system performance. A locally
    compiled kernel can also limit the risk of security problems since only
    a fraction of the kernel code is compiled and run.</para>

    <sidebar>
      <title><emphasis>NOTE</emphasis> Security updates</title>

      <para>If you choose to compile your own kernel, you must accept the
      consequences: Debian cannot ensure security updates for your custom
      kernel. By keeping the kernel provided by Debian, you benefit from
      updates prepared by the Debian Project's security team.</para>
    </sidebar>

    <para>Recompilation of the kernel is also necessary if you want to use
    certain features that are only available as patches (and not included
    in the standard kernel version).</para>

    <sidebar>
      <title><emphasis>GOING FURTHER</emphasis> The Debian Kernel Handbook</title>
      <indexterm><primary><emphasis role="pkg">debian-kernel-handbook</emphasis></primary></indexterm>

      <para>The Debian kernel teams maintains the “Debian Kernel Handbook”
      (also available in the <emphasis
      role="pkg">debian-kernel-handbook</emphasis> package) with
      comprehensive documentation about most kernel related tasks and about how
      official Debian kernel packages are handled. This is the first place
      you should look into if you need more information than what is
      provided in this section.
      <ulink url="http://kernel-handbook.alioth.debian.org" type="block"/>
      </para>
    </sidebar>

    <section id="sect.kernel-compilation-prerequisites">
      <title>Introduction and Prerequisites</title>

      <para>Unsurprisingly Debian manages the kernel in the form of a
      package, which is not how kernels have traditionally been compiled
      and installed. Since the kernel remains under
      the control of the packaging system, it can then be removed cleanly,
      or deployed on several machines. Furthermore, the scripts associated
      with these packages automate the interaction with the
      bootloader and the initrd generator.</para>

      <para>The upstream Linux sources contain everything needed to build a
      Debian package of the kernel. But you still need to install
      <emphasis role="pkg">build-essential</emphasis> to ensure that you have
      the tools required to build a Debian package. Furthermore, the
      configuration step for the kernel requires the
      <emphasis role="pkg">libncurses5-dev</emphasis> package. Finally, the
      <emphasis role="pkg">fakeroot</emphasis> package will enable creation of the
      Debian package without using administrator's rights.</para>

      <sidebar>
        <title><emphasis>CULTURE</emphasis> The good old days of <emphasis role="pkg">kernel-package</emphasis></title>
        <indexterm><primary><emphasis role="pkg">kernel-package</emphasis></primary></indexterm>

	<para>Before the Linux build system gained the ability to build
	proper Debian packages, the recommended way to build such packages
	was to use <command>make-kpkg</command> from the
	<emphasis role="pkg">kernel-package</emphasis> package.</para>
	
      </sidebar>

    </section>
    <section id="sect.kernel-sources">
      <title>Getting the Sources</title>
      <indexterm><primary>Linux kernel sources</primary></indexterm>
      <indexterm><primary>kernel</primary><secondary>sources</secondary></indexterm>
      <indexterm><primary>source</primary><secondary>of the Linux kernel</secondary></indexterm>

      <para>Like anything that can be useful on a Debian system, the Linux
      kernel sources are available in a package. To retrieve them, just
      install the <emphasis
      role="pkg">linux-source-<replaceable>version</replaceable></emphasis>
      package. The <command>apt-cache search ^linux-source</command>
      command lists the various kernel versions packaged by Debian. The
      latest version is available in the <emphasis
      role="distribution">Unstable</emphasis> distribution: you can
      retrieve them without much risk (especially if your APT is configured
      according to the instructions of <xref
      linkend="sect.apt-mix-distros"/>). Note that the source code
      contained in these packages does not correspond precisely with that
      published by Linus Torvalds and the kernel developers; like all
      distributions, Debian applies a number of patches, which might (or
      might not) find their way into the upstream version of Linux. These
      modifications include backports of fixes/features/drivers from newer
      kernel versions, new features not yet (entirely) merged in the upstream
      Linux tree, and sometimes even Debian specific changes.</para>

      <para>The remainder of this section focuses on the 3.2 version of
      the Linux kernel, but the examples can, of course, be adapted to the
      particular version of the kernel that you want.</para>

      <para>We assume the <emphasis
      role="pkg">linux-source-3.2</emphasis> package has been installed.
      It contains
      <filename>/usr/src/linux-source-3.2.tar.bz2</filename>, a
      compressed archive of the kernel sources. You must extract these
      files in a new directory (not directly under
      <filename>/usr/src/</filename>, since there is no need for special
      permissions to compile a Linux kernel):
      <filename>~/kernel/</filename> is appropriate.</para>

      <screen>
<computeroutput>$ </computeroutput><userinput>mkdir ~/kernel; cd ~/kernel</userinput>
<computeroutput>$ </computeroutput><userinput>tar -xjf /usr/src/linux-source-3.2.tar.bz2</userinput>
</screen>

      <sidebar>
        <title><emphasis>CULTURE</emphasis> Location of kernel sources</title>

	<para>Traditionally, Linux kernel sources would be placed in
	<filename>/usr/src/linux/</filename> thus requiring root
	permissions for compilation. However, working with administrator
	rights should be avoided when not needed. There is a
	<literal>src</literal> group that allows members to work in this
	directory, but working in <filename>/usr/src/</filename> should be
	avoided nevertheless. By keeping the kernel sources in a personal
	directory, you get security on all counts: no files in
	<filename>/usr/</filename> unknown to the packaging system, and
	no risk of misleading programs that read
	<filename>/usr/src/linux</filename> when trying to gather
	information on the used kernel.</para>
      </sidebar>
    </section>
    <section id="sect.config-noyau">
      <title>Configuring the Kernel</title>
      <indexterm><primary>kernel</primary><secondary>configuration</secondary></indexterm>
      <indexterm><primary>configuration</primary><secondary>of the kernel</secondary></indexterm>
      <indexterm><primary><filename>.config</filename></primary></indexterm>

      <para>The next step consists of configuring the kernel according to
      your needs. The exact procedure depends on the goals.</para>

      <para>When recompiling a more recent version of the kernel (possibly
      with an additional patch), the configuration will most likely be kept
      as close as possible to that proposed by Debian. In this case, and
      rather than reconfiguring everything from scratch, it is sufficient
      to copy the
      <filename>/boot/config-<replaceable>version</replaceable></filename>
      file (the version is that of the kernel currently used, which can be
      found with the <command>uname -r</command> command) into a
      <filename>.config</filename> file in the directory containing the
      kernel sources.</para>

      <screen>
<computeroutput>$ </computeroutput><userinput>cp /boot/config-3.2.0-4-amd64 ~/kernel/linux-source-3.2/.config</userinput>
</screen>

      <para>Unless you need to change the configuration, you can stop here
      and skip to the next section. If you need to change it, on the other
      hand, or if you decide to reconfigure everything from scratch, you
      must take the time to configure your kernel. There are various
      dedicated interfaces in the kernel source directory that can be used
      by calling the <command>make
      <replaceable>target</replaceable></command> command, where
      <replaceable>target</replaceable> is one of the values described
      below.</para>

      <para><command>make menuconfig</command> compiles and executes a
      text-mode interface (this is where the <emphasis
      role="pkg">libncurses5-dev</emphasis> package is required) which
      allows navigating the options available in a hierarchical structure.
      Pressing the <keycap>Space</keycap> key changes the value of the
      selected option, and <keycap>Enter</keycap> validates the button
      selected at the bottom of the screen; <guibutton>Select</guibutton>
      returns to the selected sub-menu; <guibutton>Exit</guibutton> closes
      the current screen and move back up in the hierarchy;
      <guibutton>Help</guibutton> will display more detailed information on
      the role of the selected option. The arrow keys allow moving within the
      list of options and buttons. To exit the configuration program,
      choose <guibutton>Exit</guibutton> from the main menu. The program
      then offers to save the changes you've made; accept if you are
      satisfied with your choices.</para>

      <para>Other interfaces have similar features, but they work within
      more modern graphical interfaces; such as <command>make
      xconfig</command> which uses a Qt graphical interface, and
      <command>make gconfig</command> which uses GTK+. The former requires
      <emphasis role="pkg">libqt4-dev</emphasis>, while the latter
      depends on <emphasis role="pkg">libglade2-dev</emphasis> and
      <emphasis role="pkg">libgtk2.0-dev</emphasis>.</para>

      <para>When using one of those configuration interfaces, it's always
      a good idea to start from a reasonable default configuration. The
      kernel provides such configurations in
      <filename>arch/<replaceable>arch</replaceable>/configs/*_defconfig</filename>
      and you can put your selected configuration in place with a command
      like <command>make x86_64_defconfig</command> (in the case of a
      64-bit PC) or <command>make i386_defconfig</command> (in the case of
      a 32-bit PC).</para>

      <sidebar>
        <title><emphasis>TIP</emphasis> Dealing with outdated <filename>.config</filename> files</title>

	<para>When you provide a <filename>.config</filename> file that has been
	generated with another (usually older) kernel version, you will have to
	update it. You can do so with <command>make oldconfig</command>, it will
	interactively ask you the questions corresponding to the new
	configuration options. If you want to use the default answer to
	all those questions you can use <command>make
	olddefconfig</command>. With <command>make oldnoconfig</command>,
	it will assume a negative answer to all questions.</para>
      </sidebar>
    </section>
    <section id="sect.kernel-build">
      <title>Compiling and Building the Package</title>
      <indexterm><primary><command>make deb-pkg</command></primary></indexterm>

      <sidebar>
        <title><emphasis>NOTE</emphasis> Clean up before rebuilding</title>

	<para>If you have already compiled once in the directory and wish
	to rebuild everything from scratch (for example because you substantially
	changed the kernel configuration), you will have to run
	<command>make clean</command> to remove the compiled files.
	<command>make distclean</command> removes even more generated files,
	including your <filename>.config</filename> file too, so make sure to
	backup it first.</para>
      </sidebar>

      <para>Once the kernel configuration is ready, a simple <command>make
      deb-pkg</command> will generate up to 5 Debian packages: <emphasis
      role="pkg">linux-image-<replaceable>version</replaceable></emphasis>
      that contains the kernel image and the associated modules,
      <emphasis role="pkg">linux-headers-<replaceable>version</replaceable></emphasis>
      which contains the header files required to build external modules,
      <emphasis role="pkg">linux-firmware-image-<replaceable>version</replaceable></emphasis>
      which contains the firmware files needed by some drivers,
      <emphasis role="pkg">linux-image-<replaceable>version</replaceable>-dbg</emphasis>
      which contains the debugging symbols for the kernel image and its modules,
      and <emphasis role="pkg">linux-libc-dev</emphasis> which contains headers
      relevant to some user space libraries like GNU glibc.</para>

      <para>The <replaceable>version</replaceable> is defined by the concatenation
      of the upstream version (as defined by the variables <literal>VERSION</literal>,
      <literal>PATCHLEVEL</literal>, <literal>SUBLEVEL</literal> and
      <literal>EXTRAVERSION</literal> in the <filename>Makefile</filename>),
      of the <literal>LOCALVERSION</literal> configuration parameter,
      and of the <literal>LOCALVERSION</literal> environment variable. The package
      version reuses the same version string with an appended revision
      that is regularly incremented (and stored in <filename>.version</filename>),
      except if you override it with the
      <literal>KDEB_PKGVERSION</literal> environment variable.
      </para>

      <screen>
<computeroutput>$ </computeroutput><userinput>make deb-pkg LOCALVERSION=-falcot KDEB_PKGVERSION=1</userinput>
[...]
<computeroutput>$ </computeroutput><userinput>ls ../*.deb</userinput>
<computeroutput>../linux-firmware-image-3.2.46-falcot_1_amd64.deb
../linux-headers-3.2.46-falcot_1_amd64.deb
../linux-image-3.2.46-falcot_1_amd64.deb
../linux-image-3.2.46-falcot-dbg_1_amd64.deb
../linux-libc-dev_1_amd64.deb
</computeroutput>
</screen>
    </section>
    <section id="sect.modules-build">
      <title>Compiling External Modules</title>
      <indexterm><primary>kernel</primary><secondary>external modules</secondary></indexterm>
      <indexterm><primary>modules</primary><secondary>external kernel modules</secondary></indexterm>
      <indexterm><primary><command>dkms</command></primary></indexterm>

      <para>Some modules are maintained outside of the official Linux
      kernel. To use them, they must be compiled alongside the matching
      kernel. A number of common third party modules are provided by Debian
      in dedicated packages, such as <emphasis
      role="pkg">virtualbox-source</emphasis> (kernel support for the VirtualBox
      virtualization solution) or <emphasis role="pkg">oss4-source</emphasis> (Open
      Sound System, some alternative audio drivers).</para>

      <para>These external packages are many and varied and we won't list
      them all here; the <command>apt-cache search source$</command>
      command can narrow down the search field. However, a complete list
      isn't particularly useful since there is no particular reason for
      compiling external modules except when you know you need it. In such
      cases, the device's documentation will typically detail the specific
      module(s) it needs to function under Linux.</para>

      <para>For example, let's look at the <emphasis
      role="pkg">virtualbox-source</emphasis> package: after installation, a
      <filename>.tar.bz2</filename> of the module's sources is stored in
      <filename>/usr/src/</filename>. While we could manually extract
      the tarball and build the module, in practice we prefer to automate
      all this using DKMS. Most modules offer the required DKMS integration
      in a package ending with a <literal>-dkms</literal> suffix. In our case,
      installing <emphasis role="pkg">virtualbox-dkms</emphasis> is all that is
      needed to compile the kernel module for the current kernel provided that
      we have the <emphasis role="pkg">linux-headers-*</emphasis> package
      matching the installed kernel. For instance, if you use
      <emphasis role="pkg">linux-images-amd64</emphasis>, you would
      also install <emphasis role="pkg">linux-headers-amd64</emphasis>.</para>

      <screen>
<computeroutput>$ </computeroutput><userinput>sudo apt-get install virtualbox-dkms</userinput>
<computeroutput>
[...]
Loading new virtualbox-4.1.18 DKMS files...
First Installation: checking all kernels...
Building only for 3.2.0-4-amd64
Building initial module for 3.2.0-4-amd64
Done.

vboxdrv:
Running module version sanity check.
 - Original module
   - No original module exists within this kernel
 - Installation
   - Installing to /lib/modules/3.2.0-4-amd64/updates/dkms/
[...]
DKMS: install completed.
$ </computeroutput><userinput>sudo dkms status</userinput>
<computeroutput>virtualbox, 4.1.18, 3.2.0-4-amd64, x86_64: installed
virtualbox-guest, 4.1.18, 3.2.0-4-amd64, x86_64: installed
$ </computeroutput><userinput>sudo modinfo vboxdrv</userinput>
<computeroutput>filename:       /lib/modules/3.2.0-4-amd64/updates/dkms/vboxdrv.ko
version:        4.1.18_Debian (0x00190000)
license:        GPL
description:    Oracle VM VirtualBox Support Driver
[...]
</computeroutput>
</screen>

      <sidebar>
        <title><emphasis>ALTERNATIVE</emphasis> module-assistant</title>
        <indexterm><primary><emphasis role="pkg">module-assistant</emphasis></primary></indexterm>

	<para>Before DKMS, <emphasis role="pkg">module-assistant</emphasis>
	was the simplest solution to build and deploy kernel modules. It
	can still be used, in particular for packages lacking DKMS
	integration: with a simple command like <command>module-assistant
	auto-install virtualbox</command>
	(or <command>m-a a-i virtualbox</command> for short),
	the modules are compiled for the current kernel, put in a new Debian package,
	and that package gets installed on the fly.
	</para>
      </sidebar>
    </section>
    <section id="sect.kernel-patch">
      <title>Applying a Kernel Patch</title>
      <indexterm><primary>kernel</primary><secondary>patch</secondary></indexterm>
      <indexterm><primary>patch of the kernel</primary></indexterm>

      <para>Some features are not included in the standard kernel due to a
      lack of maturity or to some disagreement with the kernel maintainers.
      Such features may be distributed as patches that anyone is then free
      to apply to the kernel sources.</para>

      <para>Debian distributes some of these patches in <emphasis
      role="pkg">linux-patch-*</emphasis> or <emphasis
      role="pkg">kernel-patch-*</emphasis> packages (for instance,
      <emphasis role="pkg">linux-patch-grsecurity2</emphasis>, which
      tightens some of the kernel's security policies). These packages
      install files in the <filename>/usr/src/kernel-patches/</filename>
      directory.</para>

      <para>To apply one or more of these installed patches, use the
      <command>patch</command> command in the sources directory then start
      compilation of the kernel as described above.</para>

      <screen>
<computeroutput>$ </computeroutput><userinput>cd ~/kernel/linux-source-3.2</userinput>
<computeroutput>$ </computeroutput><userinput>make clean</userinput>
<computeroutput>$ </computeroutput><userinput>zcat /usr/src/kernel-patches/diffs/grsecurity2/grsecurity-2.9.1-3.2.21-201206221855.patch.gz | patch -p1</userinput>
<computeroutput>$ </computeroutput><userinput>make deb-pkg LOCALVERSION=-grsec</userinput>
</screen>

      <para>Note that a given patch may not necessarily work with every
      version of the kernel; it is possible for <command>patch</command> to
      fail when applying them to kernel sources. An error message will be
      displayed and give some details about the failure; in this case,
      refer to the documentation available in the Debian package of the
      patch (in the <filename>/usr/share/doc/linux-patch-*/</filename>
      directory). In most cases, the maintainer indicates for which kernel
      versions their patch is intended.</para>
    </section>
  </section>
  <section id="sect.kernel-installation">
    <title>Installing a Kernel</title>
    <indexterm><primary>installation</primary><secondary>of a kernel</secondary></indexterm>
    <indexterm><primary>kernel</primary><secondary>installation</secondary></indexterm>
    <section id="sect.kernel-package">
      <title>Features of a Debian Kernel Package</title>

      <indexterm><primary><filename>vmlinuz</filename></primary></indexterm>

      <para>A Debian kernel package installs the kernel image
      (<filename>vmlinuz-<replaceable>version</replaceable></filename>),
      its configuration
      (<filename>config-<replaceable>version</replaceable></filename>) and
      its symbols table
      (<filename>System.map-<replaceable>version</replaceable></filename>)
      in <filename>/boot/</filename>. The symbols table helps
      developers understand the meaning of a kernel error message; without
      it, kernel “oopses” (an “oops” is the kernel equivalent
      of a segmentation fault for user space programs, in other
      words messages generated following an invalid pointer dereference)
      only contain numeric memory addresses, which is useless information
      without the table mapping these addresses to symbols and function
      names. The modules are installed in the
      <filename>/lib/modules/<replaceable>version</replaceable>/</filename>
      directory.</para>

      <para>The package's configuration scripts automatically generate an
      initrd image, which is a mini-system designed to be loaded in memory
      (hence the name, which stands for “init ramdisk”) by the
      bootloader, and used by the Linux kernel solely for loading the
      modules needed to access the devices containing the complete Debian
      system (for example, the driver for IDE disks). Finally, the
      post-installation scripts update the symbolic links
      <filename>/vmlinuz</filename>, <filename>/vmlinuz.old</filename>,
      <filename>/initrd.img</filename> and
      <filename>/initrd.img.old</filename> so that they point to the latest
      two kernels installed, respectively, as well as the corresponding
      initrd images.</para>

      <para>Most of those tasks are offloaded to hook scripts in
      the <filename>/etc/kernel/*.d/</filename> directories. For instance,
      the integration with <command>grub</command> relies on
      <filename>/etc/kernel/postinst.d/zz-update-grub</filename>
      and <filename>/etc/kernel/postrm.d/zz-update-grub</filename>
      to call <command>update-grub</command> when kernels
      are installed or removed.</para>
    </section>
    <section id="sect.kernel-installation-with-dpkg">
      <title>Installing with <command>dpkg</command></title>

      <para>Using <command>apt-get</command> is so convenient that it makes
      it easy to forget about the lower-level tools, but the easiest way of
      installing a compiled kernel is to use a command such as
      <command>dpkg -i <replaceable>package</replaceable>.deb</command>,
      where <literal><replaceable>package</replaceable>.deb</literal> is
      the name of a <emphasis role="pkg">linux-image</emphasis> package
      such as
      <filename>linux-image-3.2.48-falcot_1_amd64.deb</filename>.</para>

      <para>The configuration steps described in this chapter are basic and
      can lead both to a server system or a workstation, and it can be
      massively duplicated in semi-automated ways. However, it is not
      enough by itself to provide a fully configured system. A few pieces
      are still in need of configuration, starting with low-level programs
      known as the “Unix services”.</para>
    </section>
  </section>
</chapter>
